package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"net/http"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/FachschaftMathPhysInfo/kummerkasten/auth"
	"github.com/FachschaftMathPhysInfo/kummerkasten/graph/model"
	"github.com/FachschaftMathPhysInfo/kummerkasten/graph/utils"
	"github.com/FachschaftMathPhysInfo/kummerkasten/middleware"
	"github.com/FachschaftMathPhysInfo/kummerkasten/models"
	"github.com/google/uuid"
	"github.com/uptrace/bun"
)

// CreateTicket is the resolver for the createTicket field.
func (r *mutationResolver) CreateTicket(ctx context.Context, ticket model.NewTicket) (*model.Ticket, error) {
	var labels []*models.Label

	for _, labelName := range ticket.Labels {
		label := &models.Label{}
		err := r.DB.NewSelect().
			Model(label).
			Where("LOWER(name) = ?", strings.ToLower(labelName)).
			Limit(1).
			Scan(ctx)
		if err != nil {
			log.Printf("Label not found: %s", labelName)
			return nil, ErrInternal
		}
		labels = append(labels, label)
	}

	const MaxTitleLength = 70
	if len(ticket.OriginalTitle) > MaxTitleLength {
		return nil, fmt.Errorf("ticket title exceeds max length of %v", MaxTitleLength)
	}

	const MaxTextLength = 3000
	if len(ticket.Text) > MaxTextLength {
		return nil, fmt.Errorf("ticket text exceeds max length of %v", MaxTextLength)
	}

	dbTicket := &models.Ticket{
		ID:            uuid.New().String(),
		Text:          ticket.Text,
		OriginalTitle: strings.TrimSpace(ticket.OriginalTitle),
		Title:         strings.TrimSpace(ticket.OriginalTitle),
		State:         model.TicketStateNew,
		Labels:        labels,
		CreatedAt:     time.Now(),
		LastModified:  time.Now(),
	}

	if _, err := r.DB.NewInsert().Model(dbTicket).Exec(ctx); err != nil {
		log.Printf("Failed to create Ticket: %v", err)
		return nil, ErrInternal
	}

	gqlTicket := &model.Ticket{
		ID:            dbTicket.ID,
		OriginalTitle: dbTicket.Title,
		Title:         dbTicket.Title,
		Text:          dbTicket.Text,
		State:         dbTicket.State,
		CreatedAt:     dbTicket.CreatedAt,
		LastModified:  dbTicket.LastModified,
		Labels:        nil,
	}

	if len(labels) > 0 {
		var labelsToTickets []models.LabelsToTickets
		for _, label := range labels {
			labelsToTickets = append(labelsToTickets, models.LabelsToTickets{
				LabelID:  label.ID,
				TicketID: dbTicket.ID,
			})
		}
		if _, err := r.DB.NewInsert().Model(&labelsToTickets).Exec(ctx); err != nil {
			log.Printf("Failed to link labels to ticket: %v", err)
			return gqlTicket, fmt.Errorf("the ticket was created but adding labels failed")
		}
	}

	var gqlLabels []*model.Label
	for _, l := range dbTicket.Labels {
		gqlLabels = append(gqlLabels, &model.Label{
			ID:        l.ID,
			Name:      l.Name,
			Color:     l.Color,
			FormLabel: &l.FormLabel,
		})
	}

	gqlTicket.Labels = gqlLabels

	return gqlTicket, nil
}

// DeleteTicket is the resolver for the deleteTicket field.
func (r *mutationResolver) DeleteTicket(ctx context.Context, ids []string) (int32, error) {
	result, err := r.DB.NewDelete().Model((*model.Ticket)(nil)).Where("id IN (?)", bun.In(ids)).Exec(ctx)
	if err != nil {
		log.Printf("Failed to delete tickets : %v", err)
		return 0, ErrInternal
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, fmt.Errorf("the tickets were deleted, but counting them failed")
	}

	return int32(rowsAffected), nil
}

// UpdateTicket is the resolver for the updateTicket field.
func (r *mutationResolver) UpdateTicket(ctx context.Context, id string, ticket model.UpdateTicket) (string, error) {
	var dbTickets []*models.Ticket
	err := r.DB.NewSelect().
		Model(&dbTickets).
		Where("id = ?", id).
		Scan(ctx)

	if err != nil {
		log.Printf("Failed to update ticket : %v", err)
		return "", ErrInternal
	}
	if len(dbTickets) == 0 {
		return "", ErrNotFound
	}

	dbTicket := dbTickets[0]

	if ticket.Title != nil {
		const MaxTitleLength = 70
		if len(*ticket.Title) > MaxTitleLength {
			return "", fmt.Errorf("ticket title exceeds max length of %v", MaxTitleLength)
		}
		dbTicket.Title = strings.TrimSpace(*ticket.Title)
	}

	if ticket.State != nil {
		dbTicket.State = *ticket.State
	}

	dbTicket.LastModified = time.Now()

	if _, err := r.DB.NewUpdate().
		Model(dbTicket).
		WherePK().
		Exec(ctx); err != nil {
		log.Printf("Failed to update ticket %s: %v", id, err)
		return "", ErrInternal
	}

	return dbTicket.ID, nil
}

// UpdateTicketState is the resolver for the updateTicketState field.
func (r *mutationResolver) UpdateTicketState(ctx context.Context, ids []string, state model.TicketState) (int32, error) {
	result, err := r.DB.NewUpdate().Model((*models.Ticket)(nil)).
		Where("id IN (?)", bun.In(ids)).Set("state = ?", state).
		Set("last_modified = ?", time.Now()).Exec(ctx)

	if err != nil {
		log.Printf("Failed to update setting state: %v", err)
		return 0, ErrInternal
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, fmt.Errorf("the ticket states were updated, but counting them failed")
	}

	return int32(rowsAffected), nil
}

// CreateLabel is the resolver for the createLabel field.
func (r *mutationResolver) CreateLabel(ctx context.Context, label model.NewLabel) (*model.Label, error) {
	const MAXLABELLENGTH = 50

	if len(label.Name) > MAXLABELLENGTH {
		return nil, fmt.Errorf("label name exceeds max length of %v", MAXLABELLENGTH)
	}

	var labels []*models.Label

	if err := r.DB.NewSelect().Model(&labels).
		Where("LOWER(TRIM(name)) = ?", strings.ToLower(strings.TrimSpace(label.Name))).
		Scan(ctx); err != nil {
		fmt.Printf("failed creating tickets, comparisong to existing label names failed: %v", err)
		return nil, ErrInternal
	}

	if len(labels) != 0 {
		return nil, fmt.Errorf("unique constraint error: label with name %v does already exist", label.Name)
	}

	newLabel := &models.Label{
		ID:   uuid.New().String(),
		Name: strings.TrimSpace(label.Name),
	}

	if label.Color != nil {
		colorValue := *label.Color
		match, _ := regexp.MatchString("^#[[:xdigit:]]{6}$", colorValue)
		if !match {
			return nil, fmt.Errorf("color was not provided in valid hex format")
		}
		newLabel.Color = colorValue
	}

	if label.FormLabel != nil {
		newLabel.FormLabel = *label.FormLabel
	}

	formBool := newLabel.FormLabel

	if _, err := r.DB.NewInsert().Model(newLabel).Exec(ctx); err != nil {
		log.Printf("Failed to create label: %v", err)
		return nil, ErrInternal
	}

	return &model.Label{
		ID:        newLabel.ID,
		Name:      newLabel.Name,
		Color:     newLabel.Color,
		FormLabel: &formBool,
		Tickets:   []*model.Ticket{},
	}, nil
}

// DeleteLabel is the resolver for the deleteLabel field.
func (r *mutationResolver) DeleteLabel(ctx context.Context, ids []string) (int32, error) {
	result, err := r.DB.NewDelete().Model((*model.Label)(nil)).Where("id IN (?)", bun.In(ids)).Exec(ctx)
	if err != nil {
		log.Printf("Failed to delete label: %v", err)
		return 0, ErrInternal
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, fmt.Errorf("the labels were deleted, but counting them failed")
	}

	return int32(rowsAffected), nil
}

// UpdateLabel is the resolver for the updateLabel field.
func (r *mutationResolver) UpdateLabel(ctx context.Context, id string, label model.UpdateLabel) (string, error) {
	dbLabel := &models.Label{}
	err := r.DB.NewSelect().Model(dbLabel).Where("id = ?", id).Scan(ctx)

	if err != nil {
		log.Printf("Failed to find label with id %v: %v", id, err)
		return "", ErrNotFound
	}

	if label.Name != nil {
		const MAXLABELLENGTH = 50
		if len(*label.Name) > MAXLABELLENGTH {
			return "", fmt.Errorf("label name exceeds max length of %v", MAXLABELLENGTH)
		}

		var labels []*models.Label

		if err := r.DB.NewSelect().Model(&labels).
			Where("LOWER(TRIM(name)) = ?", strings.ToLower(strings.TrimSpace(*label.Name))).
			Where("id != ?", dbLabel.ID).Scan(ctx); err != nil {
			return "", ErrInternal
		}

		if len(labels) != 0 {
			return "", fmt.Errorf("unique constraint error: label with name %v does already exist", *label.Name)
		}

		dbLabel.Name = strings.TrimSpace(*label.Name)
	}

	if label.Color != nil {
		colorValue := *label.Color
		match, _ := regexp.MatchString("^#[[:xdigit:]]{6}$", colorValue)
		if !match {
			return "", fmt.Errorf("color was not provided in valid hex format")
		}

		dbLabel.Color = colorValue
	}

	if label.FormLabel != nil {
		if dbLabel.FormLabel && !*label.FormLabel {
			var allFormLabels []*models.Label
			if err := r.DB.NewSelect().
				Model(&allFormLabels).
				Where("form_label = ?", true).
				Scan(ctx); err != nil {
				log.Printf("Failed to find all form labels for update on labels: %v", err)
				return "", ErrInternal
			}
			if len(allFormLabels) == 1 {
				return "", fmt.Errorf("there must always be at least one formLabel existent")
			}
		}
		dbLabel.FormLabel = *label.FormLabel
	}

	if _, err := r.DB.NewUpdate().Model(dbLabel).WherePK().Exec(ctx); err != nil {
		log.Printf("Failed to update label %s: %v", id, err)
		return "", ErrInternal
	}

	return dbLabel.ID, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, user model.NewUser) (*model.User, error) {
	hashedPassword, err := auth.HashPassword(user.Password)

	if err != nil {
		log.Printf("Failed to create user")
	}

	userId := uuid.New().String()

	newDbUser := &models.User{
		ID:           userId,
		Mail:         strings.TrimSpace(user.Mail),
		Firstname:    strings.TrimSpace(user.Firstname),
		Lastname:     strings.TrimSpace(user.Lastname),
		Password:     hashedPassword,
		Role:         model.UserRoleUser,
		CreatedAt:    time.Now(),
		LastModified: time.Now(),
	}

	if _, err := r.DB.NewInsert().Model(newDbUser).Exec(ctx); err != nil {
		log.Printf("Failed to create user: %v", err)
		return nil, ErrInternal
	}

	gqlUser := model.User{
		ID:           newDbUser.ID,
		Mail:         newDbUser.Mail,
		Firstname:    newDbUser.Firstname,
		Lastname:     newDbUser.Lastname,
		Role:         newDbUser.Role,
		CreatedAt:    newDbUser.CreatedAt,
		LastModified: newDbUser.LastModified,
		LastLogin:    &newDbUser.LastLogin,
	}

	return &gqlUser, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, ids []string) (int32, error) {
	if len(ids) == 0 {
		return 0, fmt.Errorf("no ids provided to DeleteUser()")
	}

	result, err := r.DB.NewDelete().Model((*model.User)(nil)).Where("ID IN (?)", bun.In(ids)).Exec(ctx)

	if err != nil {
		log.Printf("Failed to delete user: %v", err)
		return 0, ErrInternal
	}

	rowsAffected, _ := result.RowsAffected()
	return int32(rowsAffected), nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, user model.UpdateUser) (string, error) {
	var dbUsers []*models.User
	err := r.DB.NewSelect().Model(&dbUsers).Where("id = ?", id).Scan(ctx)

	if err != nil || len(dbUsers) == 0 {
		log.Printf("Failed to find user with id %v: %v", id, err)
		return "", ErrNotFound
	}

	originalUser := dbUsers[0]
	updatedUser := dbUsers[0]

	if user.Mail != nil {
		updatedUser.Mail = strings.TrimSpace(*user.Mail)
	}
	if user.Firstname != nil {
		updatedUser.Firstname = strings.TrimSpace(*user.Firstname)
	}
	if user.Lastname != nil {
		updatedUser.Lastname = strings.TrimSpace(*user.Lastname)
	}
	if user.Password != nil {
		hashedPassword, err := auth.HashPassword(*user.Password)

		if err != nil {
			log.Printf("Failed to create user: %v", err)
			return "", ErrInternal
		}

		updatedUser.Password = hashedPassword
	}

	updatedUser.LastModified = time.Now()

	if _, err := r.DB.NewUpdate().Model(updatedUser).
		Where("id = ?", id).
		Exec(ctx); err != nil {
		log.Printf("Failed to update user: %v", err)
		return "", ErrInternal
	}

	if user.Mail != nil || user.Password != nil {
		if _, err := r.DB.NewDelete().
			Model((*model.Session)(nil)).
			Where("user_id = ?", originalUser.ID).
			Exec(ctx); err != nil {
			log.Printf("Failed to delete user sessions on critical data change: %v", err)
			return "", ErrInternal
		}

		newSid := uuid.New().String()
		now := time.Now()
		originalUser.LastLogin = now
		expiresAt := now.AddDate(0, 0, 2)

		newSession := &model.Session{
			ID:        newSid,
			UserID:    originalUser.ID,
			ExpiresAt: expiresAt,
		}

		if _, err := r.DB.NewInsert().Model(newSession).Exec(ctx); err != nil {
			log.Printf("Failed to create session: %v", err)
			return "", ErrInternal
		}

		httpResponseWriter := ctx.Value(middleware.WriterKey).(http.ResponseWriter)

		http.SetCookie(httpResponseWriter, &http.Cookie{
			Name:     "sid",
			Value:    newSid,
			Path:     "/",
			HttpOnly: true,
			Secure:   os.Getenv("ENV") != "DEV",
			SameSite: http.SameSiteLaxMode,
			Expires:  expiresAt,
		})
	}

	return updatedUser.ID, nil
}

// ChangeRole is the resolver for the changeRole field.
func (r *mutationResolver) ChangeRole(ctx context.Context, id string, role model.UserRole) (string, error) {
	users, err := r.Query().Users(ctx, []string{id}, make([]string, 0), nil)

	if err != nil || len(users) == 0 {
		return "", ErrNotFound
	}

	updatedUser := users[0]

	updatedUser.Role = role
	updatedUser.LastModified = time.Now()

	if _, err := r.DB.NewUpdate().Model(updatedUser).
		Where("id = ?", id).
		Exec(ctx); err != nil {
		log.Printf("Failed to update user role: %v", err)
		return "", ErrInternal
	}

	if _, err := r.DB.NewDelete().
		Model((*model.Session)(nil)).
		Where("user_id = ?", updatedUser.ID).
		Exec(ctx); err != nil {
		log.Printf("Failed to delete user sessions on role change: %v", err)
		return "", ErrInternal
	}

	return updatedUser.ID, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, id string, password string) (*bool, error) {
	var users []*models.User

	if err := r.DB.NewSelect().Model(&users).Where("id = ?", id).Scan(ctx); err != nil {
		log.Printf("Failed to fetch users for password reset: %v", err)
		return nil, ErrInternal
	}

	user := users[0]
	newPassword, err := auth.HashPassword(password)
	if err != nil {
		return nil, ErrInternal
	}

	user.Password = newPassword

	if _, err := r.DB.NewUpdate().Model(user).WherePK().Exec(ctx); err != nil {
		log.Printf("Failed to update user for password reset: %v", err)
		return nil, ErrInternal
	}

	if _, err := r.DB.NewDelete().
		Model((*model.Session)(nil)).
		Where("user_id = ?", user.ID).
		Exec(ctx); err != nil {
		log.Printf("Failed to delete user sessions on password reset: %v", err)
		return nil, ErrInternal
	}

	return nil, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context, sid string) (string, error) {
	if _, err := r.DB.NewDelete().Model((*model.Session)(nil)).
		Where("id = ?", sid).
		Exec(ctx); err != nil {
		log.Printf("Failed to logout user: %v", err)
		return "", ErrInternal
	}

	return "", nil
}

// CreateSetting is the resolver for the createSetting field.
func (r *mutationResolver) CreateSetting(ctx context.Context, setting model.NewSetting) (*model.Setting, error) {
	insertedSetting := &model.Setting{
		Value: strings.TrimSpace(setting.Value),
		Key:   setting.Key,
	}

	if _, err := r.DB.NewInsert().Model(insertedSetting).Exec(ctx); err != nil {
		log.Printf("Failed to create setting: %v", err)
		return nil, ErrInternal
	}

	return insertedSetting, nil
}

// DeleteSetting is the resolver for the deleteSetting field.
func (r *mutationResolver) DeleteSetting(ctx context.Context, keys []string) (int32, error) {
	count, err := r.DB.NewSelect().Model((*model.Setting)(nil)).Where("key IN (?)", bun.In(keys)).Count(ctx)
	if err != nil || count == 0 {
		return 0, nil
	}
	_, err = r.DB.NewDelete().Model((*model.Setting)(nil)).Where("key IN (?)", bun.In(keys)).Exec(ctx)
	if err != nil {
		log.Printf("Failed to delete settings : %v", err)
		return 0, ErrInternal
	}

	return int32(count), nil
}

// UpdateSetting is the resolver for the updateSetting field.
func (r *mutationResolver) UpdateSetting(ctx context.Context, setting model.NewSetting) (*model.Setting, error) {
	updateSetting := &model.Setting{
		Key:   setting.Key,
		Value: setting.Value,
	}

	if _, err := r.DB.NewUpdate().Model(updateSetting).Where("key = ?", setting.Key).Exec(ctx); err != nil {
		log.Printf("Failed to update setting %s: %v", setting.Key, err)
		return nil, ErrInternal
	}

	return updateSetting, nil
}

// UpdateAboutSectionText is the resolver for the updateAboutSectionText field.
func (r *mutationResolver) UpdateAboutSectionText(ctx context.Context, text string) (string, error) {
	const maxLengthAboutSectionText = 3000

	if len(text) > maxLengthAboutSectionText || len(text) == 0 {
		log.Printf("failed updating about section text: message too long or too short")
		return "", fmt.Errorf("text cannot be empty, or longer than %v", maxLengthAboutSectionText)
	}

	var settings []*model.Setting

	settings, _ = r.Query().AboutSectionSettings(ctx)

	setting := *settings[0]

	setting.Value = text

	_, err := r.DB.NewUpdate().Model(&setting).Where("key = ?", setting.Key).Exec(ctx)

	if err != nil {
		log.Printf("Failed to update setting: %v", err)
		return "", ErrInternal
	}

	return setting.Value, nil
}

// AddLabelToTicket is the resolver for the addLabelToTicket field.
func (r *mutationResolver) AddLabelToTicket(ctx context.Context, assignments []*model.LabelToTicketAssignment) (int32, error) {
	var labelsToTicketsEntries []*models.LabelsToTickets
	updatedTickets := make(map[string]struct{})

	for _, assignment := range assignments {
		if assignment.TicketID == "" || assignment.LabelID == "" {
			return 0, fmt.Errorf("ticketId and labelId cannot be empty")
		}

		labelsToTicketsEntries = append(labelsToTicketsEntries, &models.LabelsToTickets{
			TicketID: assignment.TicketID,
			LabelID:  assignment.LabelID,
		})

		updatedTickets[assignment.TicketID] = struct{}{}
	}

	for ticketID := range updatedTickets {
		_, err := r.UpdateTicket(ctx, ticketID, model.UpdateTicket{})
		if err != nil {
			log.Printf("Failed to update LastModified: %v", err)
		}
	}

	result, err := r.DB.NewInsert().Model(&labelsToTicketsEntries).Exec(ctx)

	if err != nil {
		log.Printf("Failed to add labels to tickets: %v", err)
		return 0, ErrInternal
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, fmt.Errorf("the labels were added to the tickets, but counting them failed")
	}

	return int32(rowsAffected), nil
}

// RemoveLabelFromTicket is the resolver for the removeLabelFromTicket field.
func (r *mutationResolver) RemoveLabelFromTicket(ctx context.Context, assignments []*model.LabelToTicketAssignment) (int32, error) {
	updatedTickets := make(map[string]struct{})
	var rowsAffected int64

	for _, assignment := range assignments {
		if assignment.TicketID == "" || assignment.LabelID == "" {
			return 0, fmt.Errorf("ticketId and labelId cannot be empty")
		}

		result, err := r.DB.NewDelete().Model(&models.LabelsToTickets{}).
			Where("ticket_id = ?", assignment.TicketID).
			Where("label_id = ?", assignment.LabelID).
			Exec(ctx)

		if err != nil {
			log.Printf("Failed to remove label '%s' from ticket '%s': %v", assignment.LabelID, assignment.TicketID, err)
			return int32(rowsAffected), ErrInternal
		}

		removalRowsAffected, err := result.RowsAffected()
		if err != nil {
			log.Printf("Failed to read affected rows: %v", err)
			return int32(rowsAffected), err
		}

		rowsAffected = removalRowsAffected + rowsAffected

		updatedTickets[assignment.TicketID] = struct{}{}
	}

	for ticketID := range updatedTickets {
		_, err := r.UpdateTicket(ctx, ticketID, model.UpdateTicket{})
		if err != nil {
			log.Printf("Failed to update LastModified: %v", err)
			return 0, ErrInternal
		}
	}

	return int32(rowsAffected), nil
}

// CreateQuestionAnswerPair is the resolver for the createQuestionAnswerPair field.
func (r *mutationResolver) CreateQuestionAnswerPair(ctx context.Context, questionAnswerPair model.NewQuestionAnswerPair) (*model.QuestionAnswerPair, error) {
	// The first OCCUPIED position
	var maxPositionNullable sql.NullInt32
	var maxPosition int32
	var questionExists bool
	const MaxQuestionLength = 100
	const MaxAnswerLength = 700

	if len(questionAnswerPair.Question) > MaxQuestionLength {
		return nil, fmt.Errorf("question exceeds max length of %v", MaxQuestionLength)
	}

	if len(questionAnswerPair.Answer) > MaxAnswerLength {
		return nil, fmt.Errorf("answer exceeds max length of %v", MaxAnswerLength)
	}

	questionExists, err := r.DB.NewSelect().Model((*models.QuestionAnswerPair)(nil)).
		Where("LOWER(TRIM(question)) = LOWER(?)", strings.TrimSpace(questionAnswerPair.Question)).
		Exists(ctx)

	if err != nil {
		log.Printf("Failed to get question strings for duplicate check: %v", err)
		return nil, ErrInternal
	}

	if questionExists {
		log.Print("failed to create question, it already exists")
		return nil, fmt.Errorf("this question already exists")
	}

	err = r.DB.NewSelect().Model((*models.QuestionAnswerPair)(nil)).
		ColumnExpr(`MAX("position")`).Scan(ctx, &maxPositionNullable)
	if err != nil {
		log.Printf("Failed to get max position for QuestionAnswerPair: %v", err)
		return nil, ErrInternal
	}

	if maxPositionNullable.Valid {
		maxPosition = maxPositionNullable.Int32
	} else {
		maxPosition = -1
	}

	createdQuestionAnswerPair := &model.QuestionAnswerPair{
		ID:       uuid.New().String(),
		Question: strings.TrimSpace(questionAnswerPair.Question),
		Answer:   strings.TrimSpace(questionAnswerPair.Answer),
		Position: maxPosition + 1,
	}

	if questionAnswerPair.Position != nil {
		if *questionAnswerPair.Position < 0 {
			return nil, fmt.Errorf("position must be > 0")
		} else if *questionAnswerPair.Position > maxPosition {
			createdQuestionAnswerPair.Position = maxPosition + 1
		} else {
			createdQuestionAnswerPair.Position = *questionAnswerPair.Position
		}

		if createdQuestionAnswerPair.Position <= maxPosition {
			var qaps []*model.QuestionAnswerPair
			if err := r.DB.NewSelect().
				Model(&qaps).
				Where("position >= ?", createdQuestionAnswerPair.Position).
				Order("position DESC").
				Scan(ctx); err != nil {
				log.Printf("failed to select qaps: %v", err)
				return nil, ErrInternal
			}

			for _, q := range qaps {
				if _, err := r.DB.NewUpdate().
					Model(q).
					Set(`"position" = "position" + 1`).
					Where("id = ?", q.ID).
					Exec(ctx); err != nil {
					log.Printf("failed to bump qap %v: %v", q.ID, err)
					return nil, ErrInternal
				}
			}
		}
	}

	if _, err := r.DB.NewInsert().Model(createdQuestionAnswerPair).Exec(ctx); err != nil {
		log.Printf("Failed to create QuestionAnswerPair: %v", err)
		return nil, ErrInternal
	}

	return createdQuestionAnswerPair, nil
}

// DeleteQuestionAnswerPair is the resolver for the deleteQuestionAnswerPair field.
func (r *mutationResolver) DeleteQuestionAnswerPair(ctx context.Context, ids []string) (int32, error) {
	var positions []int
	err := r.DB.NewSelect().Model((*models.QuestionAnswerPair)(nil)).
		Column("position").Where("id IN (?)", bun.In(ids)).Scan(ctx, &positions)
	if err != nil {
		log.Printf("Failed to fetch position: %v", err)
		return 0, ErrInternal
	}

	result, err := r.DB.NewDelete().Model((*model.QuestionAnswerPair)(nil)).
		Where("id IN (?)", bun.In(ids)).Exec(ctx)
	if err != nil {
		log.Printf("Failed to delete QuestionAnswerPair : %v", err)
		return 0, ErrInternal
	}

	minDeletedPosition := positions[0]
	maxDeletedPosition := positions[0]
	for _, o := range positions {
		if o < minDeletedPosition {
			minDeletedPosition = o
		}
		if o > maxDeletedPosition {
			maxDeletedPosition = o
		}
	}

	var maxPosition int
	err = r.DB.NewSelect().Model((*models.QuestionAnswerPair)(nil)).
		ColumnExpr(`MAX("position")`).Scan(ctx, &maxPosition)
	if err != nil {
		return 0, ErrInternal
	}

	for i := minDeletedPosition + 1; i <= maxPosition+1; i++ {
		_, err := r.DB.NewUpdate().Model((*models.QuestionAnswerPair)(nil)).
			Set(`"position" = ?`, i-1).Where(`"position" = ?`, i).Exec(ctx)
		if err != nil {
			log.Printf("Failed to shift QuestionAnswerPair position %v -> %v: %v", i, i-1, err)
			return 0, ErrInternal
		}
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, fmt.Errorf("the faqs were deleted, but counting them failed")
	}

	return int32(rowsAffected), nil
}

// UpdateQuestionAnswerPair is the resolver for the updateQuestionAnswerPair field.
func (r *mutationResolver) UpdateQuestionAnswerPair(ctx context.Context, id string, questionAnswerPair model.UpdateQuestionAnswerPair) (string, error) {
	questionAnswerPairs, err := r.Query().QuestionAnswerPairs(ctx, []string{id})

	if err != nil || len(questionAnswerPairs) == 0 {
		return "", ErrNotFound
	}

	const MaxQuestionLength = 100
	const MaxAnswerLength = 700

	if len(*questionAnswerPair.Question) > MaxQuestionLength {
		return "", fmt.Errorf("question exceeds max length of %v", MaxQuestionLength)
	}

	if len(*questionAnswerPair.Answer) > MaxAnswerLength {
		return "", fmt.Errorf("answer exceeds max length of %v", MaxAnswerLength)
	}

	qAP := questionAnswerPairs[0]

	if questionAnswerPair.Question != nil {
		qAP.Question = strings.TrimSpace(*questionAnswerPair.Question)

		exists, err := r.DB.NewSelect().Model((*model.QuestionAnswerPair)(nil)).
			Where("LOWER(TRIM(question)) = ?", strings.ToLower(qAP.Question)).
			Where("id != ?", qAP.ID).
			Exists(ctx)

		if err != nil {
			log.Printf("Failed to fetch questionAnswerPair for update uniquenes checj: %v", err)
			return "", ErrInternal
		}

		if exists {
			return "", fmt.Errorf("qap with this question already exists")
		}
	}
	if questionAnswerPair.Answer != nil {
		qAP.Answer = strings.TrimSpace(*questionAnswerPair.Answer)
	}

	if _, err := r.DB.NewUpdate().Model(qAP).Where("id = ?", qAP.ID).Exec(ctx); err != nil {
		log.Printf("Failed to update qap: %v", err)
		return "", ErrInternal
	}

	if questionAnswerPair.Position != nil {
		var maxPositionNullable sql.NullInt32
		var maxPosition int32

		err = r.DB.NewSelect().Model((*models.QuestionAnswerPair)(nil)).
			ColumnExpr(`MAX("position")`).
			Scan(ctx, &maxPositionNullable)

		if err != nil {
			log.Printf("Failed to fetch max position: %v", err)
			return "", ErrInternal
		}

		if maxPositionNullable.Valid {
			maxPosition = maxPositionNullable.Int32
		} else {
			maxPosition = 0
		}

		pos := *questionAnswerPair.Position

		if pos < 0 {
			return "", fmt.Errorf("position must be >= 0")
		} else if pos > maxPosition {
			if err := utils.Indices(ctx, r.DB, maxPosition, qAP.ID); err != nil {
				return "", ErrInternal
			}
		} else {
			if err := utils.Indices(ctx, r.DB, pos, qAP.ID); err != nil {
				return "", ErrInternal
			}
		}
	}

	return qAP.ID, nil
}

// UpdateQuestionAnswerPairBatchPositons is the resolver for the updateQuestionAnswerPairBatchPositons field.
func (r *mutationResolver) UpdateQuestionAnswerPairBatchPositions(ctx context.Context, questionAnswerPairs []*model.UpdateQuestionAnswerPairPosition) (bool, error) {
	amountQAPsInDB, err := r.DB.NewSelect().Model((*model.QuestionAnswerPair)(nil)).Count(ctx)
	if err != nil {
		log.Printf("Failed to fetch count of questionAnswerPairs: %v", err)
		return false, ErrInternal
	}

	if len(questionAnswerPairs) != amountQAPsInDB {
		log.Printf("Batch update count mismatch: got %v, expected %v",
			len(questionAnswerPairs), amountQAPsInDB)
		return false, fmt.Errorf("provide all qaps in batchUpdate mutation")
	}

	for i, qAP := range questionAnswerPairs {
		if int32(i) != qAP.Position {
			log.Printf("Positions in batchUpdate not consecutive at index %v: got %v", i, qAP.Position)
			return false, fmt.Errorf("positions must be consecutive (0, 1, 2, ...)")
		}
	}

	newPos := make(map[uuid.UUID]int32, len(questionAnswerPairs))
	for _, q := range questionAnswerPairs {
		idAsUUID, _ := uuid.Parse(q.ID)
		newPos[idAsUUID] = q.Position
	}

	var allQAPs []*model.QuestionAnswerPair
	if err := r.DB.NewSelect().Model(&allQAPs).Scan(ctx); err != nil {
		log.Printf("Failed to fetch all questionAnswerPairs: %v", err)
		return false, ErrInternal
	}

	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		log.Printf("Failed to begin transaction: %v", err)
		return false, ErrInternal
	}
	defer func() { _ = tx.Rollback() }()

	offset := int32(len(allQAPs))

	for _, q := range allQAPs {
		idAsUUID, _ := uuid.Parse(q.ID)
		newPosition, ok := newPos[idAsUUID]
		if !ok {
			log.Printf("ID %s missing from batch update", q.ID)
			return false, fmt.Errorf("all IDs must be included in batchUpdate mutation")
		}

		if _, err := tx.NewUpdate().
			Model(q).
			Set(`"position" = ?`, newPosition+offset).
			Where("id = ?", q.ID).
			Exec(ctx); err != nil {
			log.Printf("Failed to temporarily update position for QAP %s: %v", q.ID, err)
			return false, ErrInternal
		}
	}

	for _, q := range allQAPs {
		idAsUUID, _ := uuid.Parse(q.ID)
		finalPosition := newPos[idAsUUID]
		if _, err := tx.NewUpdate().
			Model(q).
			Set(`"position" = ?`, finalPosition).
			Where("id = ?", q.ID).
			Exec(ctx); err != nil {
			log.Printf("Failed to update final position for QAP %s: %v", q.ID, err)
			return false, ErrInternal
		}
	}

	if err := tx.Commit(); err != nil {
		log.Printf("Failed to commit batch update: %v", err)
		return false, ErrInternal
	}

	return true, nil
}

// Tickets is the resolver for the tickets field.
func (r *queryResolver) Tickets(ctx context.Context, id []string, state []model.TicketState) ([]*model.Ticket, error) {
	var dbTickets []*models.Ticket

	query := r.DB.NewSelect().Model(&dbTickets).Relation("Labels")

	if len(id) > 0 {
		query = query.Where("ticket.id IN (?)", bun.In(id))
	}

	if len(state) > 0 {
		query = query.Where("ticket.state IN (?)", bun.In(state))
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get tickets: %v", err)
		return nil, ErrInternal
	}

	var gqlTickets []*model.Ticket
	for _, t := range dbTickets {
		var gqlLabels []*model.Label
		for _, l := range t.Labels {
			form := l.FormLabel
			gqlLabels = append(gqlLabels, &model.Label{
				ID:        l.ID,
				Name:      l.Name,
				FormLabel: &form,
				Color:     l.Color,
			})
		}

		gqlTickets = append(gqlTickets, &model.Ticket{
			ID:            t.ID,
			OriginalTitle: t.OriginalTitle,
			Title:         t.Title,
			Text:          t.Text,
			Note:          &t.Note,
			State:         t.State,
			CreatedAt:     t.CreatedAt,
			LastModified:  t.LastModified,
			Labels:        gqlLabels,
		})
	}

	return gqlTickets, nil
}

// Labels is the resolver for the labels field.
func (r *queryResolver) Labels(ctx context.Context, ids []string) ([]*model.Label, error) {
	var dbLabels []*models.Label

	query := r.DB.NewSelect().Model(&dbLabels).Relation("Tickets")

	if len(ids) > 0 {
		query = query.Where("label.id IN (?)", bun.In(ids))
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get labels: %v", err)
		return nil, ErrInternal
	}

	var gqlLabels []*model.Label
	for _, l := range dbLabels {
		var gqlTickets []*model.Ticket
		for _, t := range l.Tickets {
			gqlTickets = append(gqlTickets, &model.Ticket{
				ID:           t.ID,
				Title:        t.Title,
				Text:         t.Text,
				Note:         &t.Note,
				State:        t.State,
				CreatedAt:    t.CreatedAt,
				LastModified: t.LastModified,
			})
		}

		gqlLabels = append(gqlLabels, &model.Label{
			ID:        l.ID,
			Name:      l.Name,
			Color:     l.Color,
			FormLabel: &l.FormLabel,
			Tickets:   gqlTickets,
		})
	}

	return gqlLabels, nil
}

// FormLabels is the resolver for the formLabels field.
func (r *queryResolver) FormLabels(ctx context.Context, ids []string) ([]*model.Label, error) {
	var dbLabels []*models.Label

	query := r.DB.NewSelect().Model(&dbLabels).Relation("Tickets")

	if len(ids) > 0 {
		query = query.Where("label.id IN (?)", bun.In(ids))
	}

	query = query.Where("label.form_label = ?", true)

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get form labels: %v", err)
		return nil, ErrInternal
	}

	var gqlLabels []*model.Label
	for _, l := range dbLabels {
		var gqlTickets []*model.Ticket
		for _, t := range l.Tickets {
			gqlTickets = append(gqlTickets, &model.Ticket{
				ID:           t.ID,
				Title:        t.Title,
				Text:         t.Text,
				Note:         &t.Note,
				State:        t.State,
				CreatedAt:    t.CreatedAt,
				LastModified: t.LastModified,
			})
		}

		gqlLabels = append(gqlLabels, &model.Label{
			ID:        l.ID,
			Name:      l.Name,
			Color:     l.Color,
			FormLabel: &l.FormLabel,
			Tickets:   gqlTickets,
		})
	}

	return gqlLabels, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, id []string, mail []string, role *model.UserRole) ([]*model.User, error) {
	var users []*model.User

	query := r.DB.NewSelect().Model(&users)

	if len(id) > 0 {
		query = query.Where("id IN (?)", bun.In(id))
	}
	if len(mail) > 0 {
		query = query.Where("mail IN (?)", bun.In(mail))
	}
	if role != nil {
		query = query.Where("role = ?", *role)
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to fetch users: %v", err)
		return nil, ErrInternal
	}

	return users, nil
}

// IsMailInUse is the resolver for the isMailInUse field.
func (r *queryResolver) IsMailInUse(ctx context.Context, mail string) (bool, error) {
	exists, err := r.DB.NewSelect().Model((*model.User)(nil)).Where("mail = ?", mail).Exists(ctx)
	if err != nil {
		log.Printf("Failed to fetch users for isMailInUse check: %v", err)
		return false, ErrInternal
	}

	return exists, nil
}

// Settings is the resolver for the settings field.
func (r *queryResolver) Settings(ctx context.Context, keys []string) ([]*model.Setting, error) {
	var settings []*model.Setting

	query := r.DB.NewSelect().Model(&settings)

	if len(keys) > 0 {
		query = query.Where("key IN (?)", bun.In(keys))
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get settings: %v", err)
		return nil, ErrInternal
	}

	return settings, nil
}

// FooterSettings is the resolver for the footerSettings field.
func (r *queryResolver) FooterSettings(ctx context.Context) ([]*model.Setting, error) {
	const footerSettingsPrefix = "FOOTER_"
	var footerSettings []*model.Setting

	if err := r.DB.NewSelect().
		Model(&footerSettings).
		Where("key LIKE ?", footerSettingsPrefix+"%").
		Scan(ctx); err != nil {
		log.Printf("Failed to fetch footer settings: %v", err)
		return nil, ErrInternal
	}

	return footerSettings, nil
}

// AboutSectionSettings is the resolver for the aboutSectionSettings field.
func (r *queryResolver) AboutSectionSettings(ctx context.Context) ([]*model.Setting, error) {
	const aboutSettingsPrefix = "ABOUT_"
	var aboutSetting []*model.Setting

	if err := r.DB.NewSelect().
		Model(&aboutSetting).
		Where("key LIKE ?", aboutSettingsPrefix+"%").
		Scan(ctx); err != nil {
		return nil, ErrInternal
	}

	return aboutSetting, nil
}

// Login is the resolver for the login field.
func (r *queryResolver) Login(ctx context.Context, mail string, password string) (bool, error) {
	var dbUser = new(models.User)
	err := r.DB.NewSelect().Model(dbUser).Where("mail = ?", mail).Scan(ctx)
	if err != nil || dbUser == nil {
		log.Printf("Failed to fetch user for login: %v", err)
		return false, ErrInternal
	}

	hashedPassword := dbUser.Password

	if err := auth.VerifyPassword(hashedPassword, password); err != nil {
		log.Printf("Failed login attempt for %v", mail)
		return false, fmt.Errorf("incorrect credentials")
	}

	newSid := uuid.New().String()
	now := time.Now()
	dbUser.LastLogin = now
	expiresAt := now.AddDate(0, 0, 2)

	newSession := &model.Session{
		ID:        newSid,
		UserID:    dbUser.ID,
		ExpiresAt: expiresAt,
	}

	if _, err := r.DB.NewInsert().Model(newSession).Exec(ctx); err != nil {
		log.Printf("Failed to create new session: %v", err)
		return false, ErrInternal
	}

	if _, err := r.DB.NewUpdate().Model(dbUser).Where("mail = ?", mail).Exec(ctx); err != nil {
		log.Printf("Failed to update sid: %v", err)
		return false, ErrInternal
	}

	httpResponseWriter := ctx.Value(middleware.WriterKey).(http.ResponseWriter)

	http.SetCookie(httpResponseWriter, &http.Cookie{
		Name:     "sid",
		Value:    newSid,
		Path:     "/",
		Domain:   os.Getenv("PUBLIC_DOMAIN"),
		HttpOnly: true,
		Secure:   os.Getenv("ENV") != "DEV",
		SameSite: http.SameSiteLaxMode,
		Expires:  expiresAt,
	})

	var userSessions []*model.Session
	if _, err := r.DB.NewSelect().
		Model(&userSessions).
		Where("user_id = ?", dbUser.ID).
		Order("expires_at DESC").
		Exec(ctx); err != nil {
		log.Printf("Failed to fetch user sessions: %v", err)
		return false, ErrInternal
	}

	const MaxSessionsPerUser = 20
	if len(userSessions) > MaxSessionsPerUser {
		sessionsToDelete := userSessions[:MaxSessionsPerUser]

		if _, err := r.DB.NewDelete().Model(&sessionsToDelete).Exec(ctx); err != nil {
			log.Printf("Failed to delete sessions: %v", err)
			return false, ErrInternal
		}
	}

	return true, nil
}

// LoginCheck is the resolver for the loginCheck field.
func (r *queryResolver) LoginCheck(ctx context.Context, sid *string) (*model.User, error) {
	if sid == nil {
		log.Printf("No sid provided in login check")
		return nil, nil
	}

	if _, err := uuid.Parse(*sid); err != nil {
		log.Printf("Failed to parse sid to uuid in login check: %v", err)
		return nil, nil
	}

	var sessions []*model.Session

	if err := r.DB.NewSelect().Model(&sessions).Where("id = ?", sid).Scan(ctx); err != nil {
		log.Printf("error while selection sessions from db in login check: %v", err)
		return nil, ErrInternal
	}

	if sessions == nil {
		log.Printf("Found no session for user with id: %v", *sid)
		return nil, nil
	}

	var users []*models.User

	if err := r.DB.NewSelect().Model(&users).
		Where("id = ?", sessions[0].UserID).
		Scan(ctx); err != nil {
		log.Printf("error while selection user from db after having found the session: %v", err)
		return nil, ErrInternal
	}

	if users == nil || len(users) > 1 {
		return nil, nil
	}

	gqlUser := model.User{
		ID:           users[0].ID,
		Mail:         users[0].Mail,
		Firstname:    users[0].Firstname,
		Lastname:     users[0].Lastname,
		Role:         users[0].Role,
		CreatedAt:    users[0].CreatedAt,
		LastModified: users[0].LastLogin,
		LastLogin:    &users[0].LastLogin,
	}

	return &gqlUser, nil
}

// QuestionAnswerPairs is the resolver for the questionAnswerPairs field.
func (r *queryResolver) QuestionAnswerPairs(ctx context.Context, ids []string) ([]*model.QuestionAnswerPair, error) {
	var questionAnswerPairs []*model.QuestionAnswerPair

	query := r.DB.NewSelect().Model(&questionAnswerPairs)

	if len(ids) > 0 {
		query = query.Where("id IN (?)", bun.In(ids))
	}

	query = query.Order("question_answer_pair.position ASC")

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get QuestionAnswerPairs: %v", err)
		return nil, ErrInternal
	}

	return questionAnswerPairs, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
