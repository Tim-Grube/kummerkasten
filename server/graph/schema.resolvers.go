package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"net/http"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/Plebysnacc/kummerkasten/auth"
	"github.com/Plebysnacc/kummerkasten/graph/model"
	"github.com/Plebysnacc/kummerkasten/middleware"
	"github.com/Plebysnacc/kummerkasten/models"
	"github.com/google/uuid"
	"github.com/uptrace/bun"
)

// CreateTicket is the resolver for the createTicket field.
func (r *mutationResolver) CreateTicket(ctx context.Context, ticket model.NewTicket) (*model.Ticket, error) {
	var labels []*models.Label

	for _, labelName := range ticket.Labels {
		label := &models.Label{}
		err := r.DB.NewSelect().
			Model(label).
			Where("LOWER(name) = ?", strings.ToLower(labelName)).
			Limit(1).
			Scan(ctx)
		if err != nil {
			log.Printf("Label not found: %s", labelName)
			return nil, fmt.Errorf("label not found: %s", labelName)
		}
		labels = append(labels, label)
	}

	const MaxTitleLength = 70
	if len(ticket.OriginalTitle) > MaxTitleLength {
		return nil, fmt.Errorf("ticket title exceeds max length of %v", MaxTitleLength)
	}

	const MaxTextLength = 3000
	if len(ticket.Text) > MaxTextLength {
		return nil, fmt.Errorf("ticket text exceeds max length of %v", MaxTextLength)
	}

	dbTicket := &models.Ticket{
		ID:            uuid.New().String(),
		Text:          ticket.Text,
		OriginalTitle: ticket.OriginalTitle,
		Title:         ticket.OriginalTitle,
		State:         model.TicketStateNew,
		Labels:        labels,
		CreatedAt:     time.Now(),
		LastModified:  time.Now(),
	}

	if _, err := r.DB.NewInsert().Model(dbTicket).Exec(ctx); err != nil {
		log.Printf("Failed to create Ticket: %v", err)
		return nil, ErrInternal
	}

	gqlTicket := &model.Ticket{
		ID:            dbTicket.ID,
		OriginalTitle: dbTicket.Title,
		Title:         dbTicket.Title,
		Text:          dbTicket.Text,
		State:         dbTicket.State,
		CreatedAt:     dbTicket.CreatedAt,
		LastModified:  dbTicket.LastModified,
		Labels:        nil,
	}

	if len(labels) > 0 {
		var labelsToTickets []models.LabelsToTickets
		for _, label := range labels {
			labelsToTickets = append(labelsToTickets, models.LabelsToTickets{
				LabelID:  label.ID,
				TicketID: dbTicket.ID,
			})
		}
		if _, err := r.DB.NewInsert().Model(&labelsToTickets).Exec(ctx); err != nil {
			log.Printf("Failed to link labels to ticket: %v", err)
			return gqlTicket, fmt.Errorf("the ticket was created but adding labels failed")
		}
	}

	var gqlLabels []*model.Label
	for _, l := range dbTicket.Labels {
		gqlLabels = append(gqlLabels, &model.Label{
			ID:        l.ID,
			Name:      l.Name,
			Color:     l.Color,
			FormLabel: &l.FormLabel,
		})
	}

	gqlTicket.Labels = gqlLabels

	return gqlTicket, nil
}

// DeleteTicket is the resolver for the deleteTicket field.
func (r *mutationResolver) DeleteTicket(ctx context.Context, ids []string) (int32, error) {
	result, err := r.DB.NewDelete().Model((*model.Ticket)(nil)).Where("id IN (?)", bun.In(ids)).Exec(ctx)
	if err != nil {
		log.Printf("Failed to delete tickets : %v", err)
		return 0, ErrInternal
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, fmt.Errorf("the tickets were deleted, but counting them failed")
	}

	return int32(rowsAffected), nil
}

// UpdateTicket is the resolver for the updateTicket field.
func (r *mutationResolver) UpdateTicket(ctx context.Context, id string, ticket model.UpdateTicket) (string, error) {
	dbTicket := &models.Ticket{}
	err := r.DB.NewSelect().
		Model(dbTicket).
		Where("id = ?", id).
		Limit(1).
		Scan(ctx)

	if err != nil {
		return "", fmt.Errorf("ticket with id %v not found", id)
	}

	if ticket.Title != nil {
		dbTicket.Title = *ticket.Title
	}
	if ticket.Text != nil {
		dbTicket.Text = *ticket.Text
	}
	if ticket.Note != nil {
		dbTicket.Note = *ticket.Note
	}
	if ticket.State != nil {
		dbTicket.State = *ticket.State
	}

	dbTicket.LastModified = time.Now()

	if _, err := r.DB.NewUpdate().
		Model(dbTicket).
		WherePK().
		Exec(ctx); err != nil {
		log.Printf("Failed to update ticket %s: %v", id, err)
		return "", ErrInternal
	}

	return dbTicket.ID, nil
}

// UpdateTicketState is the resolver for the updateTicketState field.
func (r *mutationResolver) UpdateTicketState(ctx context.Context, ids []string, state model.TicketState) (int32, error) {
	result, err := r.DB.NewUpdate().Model((*models.Ticket)(nil)).
		Where("id IN (?)", bun.In(ids)).Set("state = ?", state).
		Set("last_modified = ?", time.Now()).Exec(ctx)

	if err != nil {
		log.Printf("Failed to update setting state: %v", err)
		return 0, ErrInternal
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, fmt.Errorf("the ticket states were updated, but counting them failed")
	}

	return int32(rowsAffected), nil
}

// CreateLabel is the resolver for the createLabel field.
func (r *mutationResolver) CreateLabel(ctx context.Context, label model.NewLabel) (*model.Label, error) {
	const MAXLABELLENGTH = 50

	if len(label.Name) > MAXLABELLENGTH {
		return nil, fmt.Errorf("label name exceeds max length of %v", MAXLABELLENGTH)
	}

	var labels []*models.Label

	if err := r.DB.NewSelect().Model(&labels).
		Where("LOWER(TRIM(name)) = ?", strings.ToLower(strings.TrimSpace(label.Name))).
		Scan(ctx); err != nil {
		fmt.Printf("failed creating tickets, comparisong to existing label names failed: %v", err)
		return nil, ErrInternal
	}

	if len(labels) != 0 {
		return nil, fmt.Errorf("unique constraint error: label with name %v does already exist", label.Name)
	}

	newLabel := &models.Label{
		ID:   uuid.New().String(),
		Name: label.Name,
	}

	if label.Color != nil {
		colorValue := *label.Color
		match, _ := regexp.MatchString("^#[[:xdigit:]]{6}$", colorValue)
		if !match {
			return nil, fmt.Errorf("color was not provided in valid hex format")
		}
		newLabel.Color = colorValue
	}

	if label.FormLabel != nil {
		newLabel.FormLabel = *label.FormLabel
	}

	formBool := newLabel.FormLabel

	if _, err := r.DB.NewInsert().Model(newLabel).Exec(ctx); err != nil {
		log.Printf("Failed to create label: %v", err)
		return nil, ErrInternal
	}

	return &model.Label{
		ID:        newLabel.ID,
		Name:      newLabel.Name,
		Color:     newLabel.Color,
		FormLabel: &formBool,
		Tickets:   []*model.Ticket{},
	}, nil
}

// DeleteLabel is the resolver for the deleteLabel field.
func (r *mutationResolver) DeleteLabel(ctx context.Context, ids []string) (int32, error) {
	result, err := r.DB.NewDelete().Model((*model.Label)(nil)).Where("id IN (?)", bun.In(ids)).Exec(ctx)
	if err != nil {
		log.Printf("Failed to delete label: %v", err)
		return 0, ErrInternal
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, fmt.Errorf("the labels were deleted, but counting them failed")
	}

	return int32(rowsAffected), nil
}

// UpdateLabel is the resolver for the updateLabel field.
func (r *mutationResolver) UpdateLabel(ctx context.Context, id string, label model.UpdateLabel) (string, error) {
	dbLabel := &models.Label{}
	err := r.DB.NewSelect().Model(dbLabel).Where("id = ?", id).Scan(ctx)

	if err != nil {
		log.Printf("Failed to find label with id %v: %v", id, err)
		return "", fmt.Errorf("label with id %v not found", id)
	}

	if label.Name != nil {
		const MAXLABELLENGTH = 50
		if len(*label.Name) > MAXLABELLENGTH {
			return "", fmt.Errorf("label name exceeds max length of %v", MAXLABELLENGTH)
		}

		var labels []*models.Label

		if err := r.DB.NewSelect().Model(&labels).
			Where("LOWER(TRIM(name)) = ?", strings.ToLower(strings.TrimSpace(*label.Name))).
			Where("id != ?", dbLabel.ID).Scan(ctx); err != nil {
			return "", ErrInternal
		}

		if len(labels) != 0 {
			return "", fmt.Errorf("unique constraint error: label with name %v does already exist", *label.Name)
		}

		dbLabel.Name = *label.Name
	}

	if label.Color != nil {
		colorValue := *label.Color
		match, _ := regexp.MatchString("^#[[:xdigit:]]{6}$", colorValue)
		if !match {
			return "", fmt.Errorf("color was not provided in valid hex format")
		}

		dbLabel.Color = colorValue
	}

	if label.FormLabel != nil {
		if dbLabel.FormLabel && !*label.FormLabel {
			var allFormLabels []*models.Label
			if err := r.DB.NewSelect().
				Model(&allFormLabels).
				Where("form_label = ?", true).
				Scan(ctx); err != nil {
				log.Printf("Failed to find all form labels for update on labels: %v", err)
				return "", fmt.Errorf("internal server error")
			}
			if len(allFormLabels) == 1 {
				return "", fmt.Errorf("there must always be at least one formLabel existent")
			}
		}
		dbLabel.FormLabel = *label.FormLabel
	}

	if _, err := r.DB.NewUpdate().Model(dbLabel).WherePK().Exec(ctx); err != nil {
		log.Printf("Failed to update label %s: %v", id, err)
		return "", ErrInternal
	}

	return dbLabel.ID, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, user model.NewUser) (*model.User, error) {
	hashedPassword, err := auth.HashPassword(user.Password)

	if err != nil {
		log.Printf("Failed to create user")
	}

	userId := uuid.New().String()

	newUser := &model.User{
		ID:           userId,
		Mail:         user.Mail,
		Firstname:    user.Firstname,
		Lastname:     user.Lastname,
		Password:     hashedPassword,
		Role:         model.UserRoleUser,
		CreatedAt:    time.Now(),
		LastModified: time.Now(),
	}

	if _, err := r.DB.NewInsert().Model(newUser).Exec(ctx); err != nil {
		log.Printf("Failed to create user: %v", err)
		return nil, ErrInternal
	}

	return newUser, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, ids []string) (int32, error) {
	if len(ids) == 0 {
		return 0, fmt.Errorf("no ids provided to DeleteUser()")
	}

	result, err := r.DB.NewDelete().Model((*model.User)(nil)).Where("ID IN (?)", bun.In(ids)).Exec(ctx)

	if err != nil {
		log.Printf("Failed to delete user: %v", err)
		return 0, ErrInternal
	}

	rowsAffected, _ := result.RowsAffected()
	return int32(rowsAffected), nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, user model.UpdateUser) (string, error) {
	users, err := r.Query().Users(ctx, []string{id}, make([]string, 0), nil)

	if err != nil || len(users) == 0 {
		log.Printf("Failed to find user with id %v: %v", id, err)
		return "", fmt.Errorf("user with id %v not found", id)
	}

	originalUser := users[0]
	updatedUser := users[0]

	if user.Mail != nil {
		updatedUser.Mail = *user.Mail
	}
	if user.Firstname != nil {
		updatedUser.Firstname = *user.Firstname
	}
	if user.Lastname != nil {
		updatedUser.Lastname = *user.Lastname
	}
	if user.Password != nil {
		hashedPassword, err := auth.HashPassword(*user.Password)

		if err != nil {
			log.Printf("Failed to create user: %v", err)
			return "", ErrInternal
		}

		updatedUser.Password = hashedPassword
	}

	updatedUser.LastModified = time.Now()

	if _, err := r.DB.NewUpdate().Model(updatedUser).
		Where("id = ?", id).
		Exec(ctx); err != nil {
		log.Printf("Failed to update user: %v", err)
		return "", ErrInternal
	}

	if user.Mail != nil || user.Password != nil {
		if _, err := r.DB.NewDelete().
			Model((*model.Session)(nil)).
			Where("user_id = ?", originalUser.ID).
			Exec(ctx); err != nil {
			log.Printf("Failed to delete user sessions on critical data change: %v", err)
			return "", fmt.Errorf("internal system error")
		}

		newSid := uuid.New().String()
		now := time.Now()
		originalUser.LastLogin = &now
		expiresAt := now.AddDate(0, 0, 2)

		newSession := &model.Session{
			ID:        newSid,
			UserID:    originalUser.ID,
			ExpiresAt: expiresAt,
		}

		if _, err := r.DB.NewInsert().Model(newSession).Exec(ctx); err != nil {
			log.Printf("Failed to create session: %v", err)
			return "", fmt.Errorf("internal system error")
		}

		httpResponseWriter := ctx.Value(middleware.WriterKey).(http.ResponseWriter)

		http.SetCookie(httpResponseWriter, &http.Cookie{
			Name:     "sid",
			Value:    newSid,
			Path:     "/",
			HttpOnly: true,
			Secure:   os.Getenv("ENV") != "DEV",
			SameSite: http.SameSiteLaxMode,
			Expires:  expiresAt,
		})
	}

	return updatedUser.ID, nil
}

// ChangeRole is the resolver for the changeRole field.
func (r *mutationResolver) ChangeRole(ctx context.Context, id string, role model.UserRole) (string, error) {
	users, err := r.Query().Users(ctx, []string{id}, make([]string, 0), nil)

	if err != nil || len(users) == 0 {
		return "", fmt.Errorf("user with id %v not found", id)
	}

	updatedUser := users[0]

	updatedUser.Role = role
	updatedUser.LastModified = time.Now()

	if _, err := r.DB.NewUpdate().Model(updatedUser).
		Where("id = ?", id).
		Exec(ctx); err != nil {
		log.Printf("Failed to update user role: %v", err)
		return "", ErrInternal
	}

	if _, err := r.DB.NewDelete().
		Model((*model.Session)(nil)).
		Where("user_id = ?", updatedUser.ID).
		Exec(ctx); err != nil {
		log.Printf("Failed to delete user sessions on role change: %v", err)
		return "", fmt.Errorf("internal system error")
	}

	return updatedUser.ID, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, id string, password string) (*bool, error) {
	var users []*models.User

	if err := r.DB.NewSelect().Model(&users).Where("id = ?", id).Scan(ctx); err != nil {
		log.Printf("Failed to fetch users for password reset: %v", err)
		return nil, ErrInternal
	}

	user := users[0]
	newPassword, err := auth.HashPassword(password)
	if err != nil {
		return nil, ErrInternal
	}

	user.Password = newPassword

	if _, err := r.DB.NewUpdate().Model(user).WherePK().Exec(ctx); err != nil {
		log.Printf("Failed to update user for password reset: %v", err)
		return nil, ErrInternal
	}

	if _, err := r.DB.NewDelete().
		Model((*model.Session)(nil)).
		Where("user_id = ?", user.ID).
		Exec(ctx); err != nil {
		log.Printf("Failed to delete user sessions on password reset: %v", err)
		return nil, fmt.Errorf("internal system error")
	}

	return nil, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context, sid string) (string, error) {
	if _, err := r.DB.NewDelete().Model((*model.Session)(nil)).
		Where("id = ?", sid).
		Exec(ctx); err != nil {
		log.Printf("Failed to logout user: %v", err)
		return "", ErrInternal
	}

	return "", nil
}

// CreateSetting is the resolver for the createSetting field.
func (r *mutationResolver) CreateSetting(ctx context.Context, setting model.NewSetting) (*model.Setting, error) {
	insertedSetting := &model.Setting{
		Value: setting.Value,
		Key:   setting.Key,
	}

	if _, err := r.DB.NewInsert().Model(insertedSetting).Exec(ctx); err != nil {
		log.Printf("Failed to create setting: %v", err)
		return nil, ErrInternal
	}

	return insertedSetting, nil
}

// DeleteSetting is the resolver for the deleteSetting field.
func (r *mutationResolver) DeleteSetting(ctx context.Context, keys []string) (int32, error) {
	count, err := r.DB.NewSelect().Model((*model.Setting)(nil)).Where("key IN (?)", bun.In(keys)).Count(ctx)
	if err != nil || count == 0 {
		return 0, nil
	}
	_, err = r.DB.NewDelete().Model((*model.Setting)(nil)).Where("key IN (?)", bun.In(keys)).Exec(ctx)
	if err != nil {
		log.Printf("Failed to delete settings : %v", err)
		return 0, ErrInternal
	}

	return int32(count), nil
}

// UpdateSetting is the resolver for the updateSetting field.
func (r *mutationResolver) UpdateSetting(ctx context.Context, setting model.NewSetting) (*model.Setting, error) {
	updateSetting := &model.Setting{
		Key:   setting.Key,
		Value: setting.Value,
	}

	if _, err := r.DB.NewUpdate().Model(updateSetting).Where("key = ?", setting.Key).Exec(ctx); err != nil {
		log.Printf("Failed to update setting %s: %v", setting.Key, err)
		return nil, ErrInternal
	}

	return updateSetting, nil
}

// UpdateAboutSectionText is the resolver for the updateAboutSectionText field.
func (r *mutationResolver) UpdateAboutSectionText(ctx context.Context, text string) (string, error) {
	const maxLengthAboutSectionText = 3000

	if len(text) > maxLengthAboutSectionText || len(text) == 0 {
		log.Printf("failed updating about section text: message too long or too short")
		return "", fmt.Errorf("text cannot be empty, or longer than %v", maxLengthAboutSectionText)
	}

	var settings []*model.Setting

	settings, _ = r.Query().AboutSectionSettings(ctx)

	setting := *settings[0]

	setting.Value = text

	_, err := r.DB.NewUpdate().Model(&setting).Where("key = ?", setting.Key).Exec(ctx)

	if err != nil {
		log.Printf("Failed to update setting: %v", err)
		return "", fmt.Errorf("internal server error")
	}

	return setting.Value, nil
}

// AddLabelToTicket is the resolver for the addLabelToTicket field.
func (r *mutationResolver) AddLabelToTicket(ctx context.Context, assignments []*model.LabelToTicketAssignment) (int32, error) {
	var labelsToTicketsEntries []*models.LabelsToTickets
	updatedTickets := make(map[string]struct{})

	for _, assignment := range assignments {
		if assignment.TicketID == "" || assignment.LabelID == "" {
			return 0, fmt.Errorf("ticketId and labelId cannot be empty")
		}

		labelsToTicketsEntries = append(labelsToTicketsEntries, &models.LabelsToTickets{
			TicketID: assignment.TicketID,
			LabelID:  assignment.LabelID,
		})

		updatedTickets[assignment.TicketID] = struct{}{}
	}

	for ticketID := range updatedTickets {
		_, err := r.UpdateTicket(ctx, ticketID, model.UpdateTicket{})
		if err != nil {
			log.Printf("Failed to update LastModified: %v", err)
		}
	}

	result, err := r.DB.NewInsert().Model(&labelsToTicketsEntries).Exec(ctx)

	if err != nil {
		log.Printf("Failed to add labels to tickets: %v", err)
		return 0, ErrInternal
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, fmt.Errorf("the labels were added to the tickets, but counting them failed")
	}

	return int32(rowsAffected), nil
}

// RemoveLabelFromTicket is the resolver for the removeLabelFromTicket field.
func (r *mutationResolver) RemoveLabelFromTicket(ctx context.Context, assignments []*model.LabelToTicketAssignment) (int32, error) {
	updatedTickets := make(map[string]struct{})
	var rowsAffected int64

	for _, assignment := range assignments {
		if assignment.TicketID == "" || assignment.LabelID == "" {
			return 0, fmt.Errorf("ticketId and labelId cannot be empty")
		}

		result, err := r.DB.NewDelete().Model(&models.LabelsToTickets{}).
			Where("ticket_id = ?", assignment.TicketID).
			Where("label_id = ?", assignment.LabelID).
			Exec(ctx)

		if err != nil {
			log.Printf("Failed to remove label '%s' from ticket '%s': %v", assignment.LabelID, assignment.TicketID, err)
			return int32(rowsAffected), ErrInternal
		}

		removalRowsAffected, err := result.RowsAffected()
		if err != nil {
			log.Printf("Failed to read affected rows: %v", err)
			return int32(rowsAffected), err
		}

		rowsAffected = removalRowsAffected + rowsAffected

		updatedTickets[assignment.TicketID] = struct{}{}
	}

	for ticketID := range updatedTickets {
		_, err := r.UpdateTicket(ctx, ticketID, model.UpdateTicket{})
		if err != nil {
			log.Printf("Failed to update LastModified: %v", err)
			return 0, ErrInternal
		}
	}

	return int32(rowsAffected), nil
}

// CreateQuestionAnswerPair is the resolver for the createQuestionAnswerPair field.
func (r *mutationResolver) CreateQuestionAnswerPair(ctx context.Context, questionAnswerPair model.NewQuestionAnswerPair) (*model.QuestionAnswerPair, error) {
	var maxOrder sql.NullInt32
	var questionExists bool
	const MaxQuestionLength = 100
	const MaxAnswerLength = 700

	if len(questionAnswerPair.Question) > MaxQuestionLength {
		return nil, fmt.Errorf("question exceeds max length of %v", MaxQuestionLength)
	}

	if len(questionAnswerPair.Answer) > MaxAnswerLength {
		return nil, fmt.Errorf("answer exceeds max length of %v", MaxAnswerLength)
	}

	questionExists, err := r.DB.NewSelect().Model((*models.QuestionAnswerPair)(nil)).
		Where("LOWER(question) = LOWER(?)", questionAnswerPair.Question).
		Exists(ctx)

	if err != nil {
		log.Printf("Failed to get question strings for duplicate check: %v", err)
		return nil, ErrInternal
	}

	if questionExists {
		log.Printf("This question already exists: %v", err)
		return nil, fmt.Errorf("this question already exists")
	}

	err = r.DB.NewSelect().Model((*models.QuestionAnswerPair)(nil)).
		ColumnExpr(`MAX("order")`).Scan(ctx, &maxOrder)
	if err != nil {
		log.Printf("Failed to get max order for QuestionAnswerPair: %v", err)
		return nil, ErrInternal
	}

	createdQuestionAnswerPair := &model.QuestionAnswerPair{
		ID:       uuid.New().String(),
		Question: questionAnswerPair.Question,
		Answer:   questionAnswerPair.Answer,
		Order:    maxOrder.Int32 + 1,
	}

	if !maxOrder.Valid {
		createdQuestionAnswerPair.Order = 0
	}

	if _, err := r.DB.NewInsert().Model(createdQuestionAnswerPair).Exec(ctx); err != nil {
		log.Printf("Failed to create QuestionAnswerPair: %v", err)
		return nil, ErrInternal
	}

	return createdQuestionAnswerPair, nil
}

// DeleteQuestionAnswerPair is the resolver for the deleteQuestionAnswerPair field.
func (r *mutationResolver) DeleteQuestionAnswerPair(ctx context.Context, ids []string) (int32, error) {
	var orders []int
	err := r.DB.NewSelect().Model((*models.QuestionAnswerPair)(nil)).
		Column("order").Where("id IN (?)", bun.In(ids)).Scan(ctx, &orders)
	if err != nil {
		log.Printf("Failed to fetch order: %v", err)
		return 0, ErrInternal
	}

	result, err := r.DB.NewDelete().Model((*model.QuestionAnswerPair)(nil)).
		Where("id IN (?)", bun.In(ids)).Exec(ctx)
	if err != nil {
		log.Printf("Failed to delete QuestionAnswerPair : %v", err)
		return 0, ErrInternal
	}

	minDeletedOrder := orders[0]
	maxDeletedOrder := orders[0]
	for _, o := range orders {
		if o < minDeletedOrder {
			minDeletedOrder = o
		}
		if o > maxDeletedOrder {
			maxDeletedOrder = o
		}
	}

	var maxOrder int
	err = r.DB.NewSelect().Model((*models.QuestionAnswerPair)(nil)).
		ColumnExpr(`MAX("order")`).Scan(ctx, &maxOrder)
	if err != nil {
		return 0, ErrInternal
	}

	for i := minDeletedOrder + 1; i <= maxOrder+1; i++ {
		_, err := r.DB.NewUpdate().Model((*models.QuestionAnswerPair)(nil)).
			Set(`"order" = ?`, i-1).Where(`"order" = ?`, i).Exec(ctx)
		if err != nil {
			log.Printf("Failed to shift QuestionAnswerPair order %d -> %d: %v", i, i-1, err)
			return 0, ErrInternal
		}
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, fmt.Errorf("the faqs were deleted, but counting them failed")
	}

	return int32(rowsAffected), nil
}

// UpdateQuestionAnswerPair is the resolver for the updateQuestionAnswerPair field.
func (r *mutationResolver) UpdateQuestionAnswerPair(ctx context.Context, id string, questionAnswerPair model.UpdateQuestionAnswerPair) (string, error) {
	questionAnswerPairs, err := r.Query().QuestionAnswerPairs(ctx, []string{id})

	if err != nil || len(questionAnswerPairs) == 0 {
		return "", fmt.Errorf("QuestionAnswerPair with id %v not found", id)
	}

	const MaxQuestionLength = 100
	const MaxAnswerLength = 700

	if len(*questionAnswerPair.Question) > MaxQuestionLength {
		return "", fmt.Errorf("question exceeds max length of %v", MaxQuestionLength)
	}

	if len(*questionAnswerPair.Answer) > MaxAnswerLength {
		return "", fmt.Errorf("answer exceeds max length of %v", MaxAnswerLength)
	}

	qAP := questionAnswerPairs[0]

	if questionAnswerPair.Question != nil {
		qAP.Question = *questionAnswerPair.Question
	}
	if questionAnswerPair.Answer != nil {
		qAP.Answer = *questionAnswerPair.Answer
	}

	if _, err := r.DB.NewUpdate().Model(qAP).
		Where("id = ?", id).
		Exec(ctx); err != nil {
		log.Printf("Failed to update QuestionAnswerPair: %v", err)
		return "", ErrInternal
	}

	return qAP.ID, nil
}

// UpdateQuestionAnswerPairOrder is the resolver for the UpdateQuestionAnswerPairOrder field.
func (r *mutationResolver) UpdateQuestionAnswerPairOrder(ctx context.Context, qaps []*model.UpdateQuestionAnswerPairOrder) (int32, error) {
	qap := qaps[0]

	var maxOrder int32
	err := r.DB.NewSelect().Model((*models.QuestionAnswerPair)(nil)).
		ColumnExpr(`MAX("order")`).Scan(ctx, &maxOrder)
	if err != nil {
		return 0, ErrInternal
	}

	var currentOrder int
	err = r.DB.NewSelect().Model((*models.QuestionAnswerPair)(nil)).
		Column("order").Where("id = ?", qap.ID).Scan(ctx, &currentOrder)
	if err != nil {
		return 0, ErrInternal
	}

	if qap.Order > maxOrder {
		qap.Order = maxOrder
	}

	_, err = r.DB.NewUpdate().Model((*models.QuestionAnswerPair)(nil)).
		Set(`"order" = ?`, -1).Where("id = ?", qap.ID).Exec(ctx)
	if err != nil {
		return 0, ErrInternal
	}

	if qap.Order < int32(currentOrder) {
		for i := currentOrder - 1; i >= int(qap.Order); i-- {
			_, err := r.DB.NewUpdate().Model((*models.QuestionAnswerPair)(nil)).
				Set(`"order" = ?`, i+1).Where(`"order" = ?`, i).Exec(ctx)
			if err != nil {
				log.Printf("Failed to shift QuestionAnswerPairs order up %d -> %d: %v", i, i+1, err)
				return 0, ErrInternal
			}
		}
	} else if qap.Order > int32(currentOrder) {
		for i := currentOrder + 1; i <= int(qap.Order); i++ {
			_, err := r.DB.NewUpdate().Model((*models.QuestionAnswerPair)(nil)).
				Set(`"order" = ?`, i-1).Where(`"order" = ?`, i).Exec(ctx)
			if err != nil {
				log.Printf("Failed to shift QuestionAnswerPairs order down %d -> %d: %v", i, i-1, err)
				return 0, ErrInternal
			}
		}
	}

	result, err := r.DB.NewUpdate().Model((*models.QuestionAnswerPair)(nil)).
		Set(`"order" = ?`, int(qap.Order)).Where("id = ?", qap.ID).Exec(ctx)
	if err != nil {
		log.Printf("Failed to update QuestionAnswerPair order for ID %s: %v", qap.ID, err)
		return 0, ErrInternal
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, fmt.Errorf("update was successful, but counting failed")
	}

	return int32(rowsAffected), nil
}

// Tickets is the resolver for the tickets field.
func (r *queryResolver) Tickets(ctx context.Context, id []string, state []model.TicketState) ([]*model.Ticket, error) {
	var dbTickets []*models.Ticket

	query := r.DB.NewSelect().Model(&dbTickets).Relation("Labels")

	if len(id) > 0 {
		query = query.Where("ticket.id IN (?)", bun.In(id))
	}

	if len(state) > 0 {
		query = query.Where("ticket.state IN (?)", bun.In(state))
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get tickets: %v", err)
		return nil, fmt.Errorf("failed to fetch tickets")
	}

	var gqlTickets []*model.Ticket
	for _, t := range dbTickets {
		var gqlLabels []*model.Label
		for _, l := range t.Labels {
			form := l.FormLabel
			gqlLabels = append(gqlLabels, &model.Label{
				ID:        l.ID,
				Name:      l.Name,
				FormLabel: &form,
				Color:     l.Color,
			})
		}

		gqlTickets = append(gqlTickets, &model.Ticket{
			ID:            t.ID,
			OriginalTitle: t.OriginalTitle,
			Title:         t.Title,
			Text:          t.Text,
			Note:          &t.Note,
			State:         t.State,
			CreatedAt:     t.CreatedAt,
			LastModified:  t.LastModified,
			Labels:        gqlLabels,
		})
	}

	return gqlTickets, nil
}

// Labels is the resolver for the labels field.
func (r *queryResolver) Labels(ctx context.Context, ids []string) ([]*model.Label, error) {
	var dbLabels []*models.Label

	query := r.DB.NewSelect().Model(&dbLabels).Relation("Tickets")

	if len(ids) > 0 {
		query = query.Where("label.id IN (?)", bun.In(ids))
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get labels: %v", err)
		return nil, fmt.Errorf("failed to fetch labels")
	}

	var gqlLabels []*model.Label
	for _, l := range dbLabels {
		var gqlTickets []*model.Ticket
		for _, t := range l.Tickets {
			gqlTickets = append(gqlTickets, &model.Ticket{
				ID:           t.ID,
				Title:        t.Title,
				Text:         t.Text,
				Note:         &t.Note,
				State:        t.State,
				CreatedAt:    t.CreatedAt,
				LastModified: t.LastModified,
			})
		}

		gqlLabels = append(gqlLabels, &model.Label{
			ID:        l.ID,
			Name:      l.Name,
			Color:     l.Color,
			FormLabel: &l.FormLabel,
			Tickets:   gqlTickets,
		})
	}

	return gqlLabels, nil
}

// FormLabels is the resolver for the formLabels field.
func (r *queryResolver) FormLabels(ctx context.Context, ids []string) ([]*model.Label, error) {
	var dbLabels []*models.Label

	query := r.DB.NewSelect().Model(&dbLabels).Relation("Tickets")

	if len(ids) > 0 {
		query = query.Where("label.id IN (?)", bun.In(ids))
	}

	query = query.Where("label.form_label = ?", true)

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get form labels: %v", err)
		return nil, fmt.Errorf("failed to fetch form labels")
	}

	var gqlLabels []*model.Label
	for _, l := range dbLabels {
		var gqlTickets []*model.Ticket
		for _, t := range l.Tickets {
			gqlTickets = append(gqlTickets, &model.Ticket{
				ID:           t.ID,
				Title:        t.Title,
				Text:         t.Text,
				Note:         &t.Note,
				State:        t.State,
				CreatedAt:    t.CreatedAt,
				LastModified: t.LastModified,
			})
		}

		gqlLabels = append(gqlLabels, &model.Label{
			ID:        l.ID,
			Name:      l.Name,
			Color:     l.Color,
			FormLabel: &l.FormLabel,
			Tickets:   gqlTickets,
		})
	}

	return gqlLabels, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, id []string, mail []string, role *model.UserRole) ([]*model.User, error) {
	var users []*model.User

	query := r.DB.NewSelect().Model(&users)

	if len(id) > 0 {
		query = query.Where("id IN (?)", bun.In(id))
	}
	if len(mail) > 0 {
		query = query.Where("mail IN (?)", bun.In(mail))
	}
	if role != nil {
		query = query.Where("role = ?", *role)
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to fetch users: %v", err)
		return nil, fmt.Errorf("failed to fetch footer users")
	}

	return users, nil
}

// IsMailInUse is the resolver for the isMailInUse field.
func (r *queryResolver) IsMailInUse(ctx context.Context, mail string) (bool, error) {
	exists, err := r.DB.NewSelect().Model((*model.User)(nil)).Where("mail = ?", mail).Exists(ctx)
	if err != nil {
		log.Printf("Failed to fetch users for isMailInUse check: %v", err)
		return false, fmt.Errorf("internal server error")
	}

	return exists, nil
}

// Settings is the resolver for the settings field.
func (r *queryResolver) Settings(ctx context.Context, keys []string) ([]*model.Setting, error) {
	var settings []*model.Setting

	query := r.DB.NewSelect().Model(&settings)

	if len(keys) > 0 {
		query = query.Where("key IN (?)", bun.In(keys))
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get settings: %v", err)
		return nil, fmt.Errorf("failed to fetch settings")
	}

	return settings, nil
}

// FooterSettings is the resolver for the footerSettings field.
func (r *queryResolver) FooterSettings(ctx context.Context) ([]*model.Setting, error) {
	const footerSettingsPrefix = "FOOTER_"
	var footerSettings []*model.Setting

	if err := r.DB.NewSelect().
		Model(&footerSettings).
		Where("key LIKE ?", footerSettingsPrefix+"%").
		Scan(ctx); err != nil {
		log.Printf("Failed to fetch footer settings: %v", err)
		return nil, fmt.Errorf("failed to fetch footer settings")
	}

	return footerSettings, nil
}

// AboutSectionSettings is the resolver for the aboutSectionSettings field.
func (r *queryResolver) AboutSectionSettings(ctx context.Context) ([]*model.Setting, error) {
	const aboutSettingsPrefix = "ABOUT_"
	var aboutSetting []*model.Setting

	if err := r.DB.NewSelect().
		Model(&aboutSetting).
		Where("key LIKE ?", aboutSettingsPrefix+"%").
		Scan(ctx); err != nil {
		return nil, fmt.Errorf("failed to fetch about setting: %v", err)
	}

	return aboutSetting, nil
}

// Login is the resolver for the login field.
func (r *queryResolver) Login(ctx context.Context, mail string, password string) (bool, error) {
	users, err := r.Users(ctx, make([]string, 0), []string{mail}, nil)
	if err != nil || len(users) == 0 {
		log.Printf("Failed to fetch user for login: %v", err)
		return false, ErrInternal
	}

	user := users[0]
	hashedPassword := user.Password

	if err := auth.VerifyPassword(hashedPassword, password); err != nil {
		log.Printf("Password is incorrect for %v is incorrect", user.Mail)
		return false, fmt.Errorf("incorrect credentials")
	}

	newSid := uuid.New().String()
	now := time.Now()
	user.LastLogin = &now
	expiresAt := now.AddDate(0, 0, 2)

	newSession := &model.Session{
		ID:        newSid,
		UserID:    user.ID,
		ExpiresAt: expiresAt,
	}

	if _, err := r.DB.NewInsert().Model(newSession).Exec(ctx); err != nil {
		log.Printf("Failed to create new session: %v", err)
		return false, ErrInternal
	}

	if _, err := r.DB.NewUpdate().Model(user).Where("mail = ?", mail).Exec(ctx); err != nil {
		log.Printf("Failed to update sid: %v", err)
		return false, ErrInternal
	}

	httpResponseWriter := ctx.Value(middleware.WriterKey).(http.ResponseWriter)

	http.SetCookie(httpResponseWriter, &http.Cookie{
		Name:     "sid",
		Value:    newSid,
		Path:     "/",
		HttpOnly: true,
		Secure:   os.Getenv("ENV") != "DEV",
		SameSite: http.SameSiteLaxMode,
		Expires:  expiresAt,
	})

	var userSessions []*model.Session
	if _, err := r.DB.NewSelect().
		Model(&userSessions).
		Where("user_id = ?", user.ID).
		Order("expires_at DESC").
		Exec(ctx); err != nil {
		log.Printf("Failed to fetch user sessions: %v", err)
		return false, ErrInternal
	}

	const MaxSessionsPerUser = 20
	if len(userSessions) > MaxSessionsPerUser {
		sessionsToDelete := userSessions[:MaxSessionsPerUser]

		if _, err := r.DB.NewDelete().Model(&sessionsToDelete).Exec(ctx); err != nil {
			log.Printf("Failed to delete sessions: %v", err)
			return false, ErrInternal
		}
	}

	return true, nil
}

// LoginCheck is the resolver for the loginCheck field.
func (r *queryResolver) LoginCheck(ctx context.Context, sid *string) (*model.User, error) {
	if sid == nil {
		return nil, nil
	}

	var sessions []*model.Session

	if err := r.DB.NewSelect().Model(&sessions).Where("id = ?", sid).Scan(ctx); err != nil {
		return nil, ErrInternal
	}

	if sessions == nil {
		return nil, nil
	}

	var users []*model.User

	if err := r.DB.NewSelect().Model(&users).
		Where("id = ?", sessions[0].UserID).
		Scan(ctx); err != nil {
		return nil, ErrInternal
	}

	if users == nil || len(users) > 1 {
		return nil, nil
	}

	return users[0], nil
}

// QuestionAnswerPairs is the resolver for the questionAnswerPairs field.
func (r *queryResolver) QuestionAnswerPairs(ctx context.Context, ids []string) ([]*model.QuestionAnswerPair, error) {
	var questionAnswerPairs []*model.QuestionAnswerPair

	query := r.DB.NewSelect().Model(&questionAnswerPairs)

	if len(ids) > 0 {
		query = query.Where("id IN (?)", bun.In(ids))
	}

	query = query.Order("question_answer_pair.order ASC")

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get QuestionAnswerPairs: %v", err)
		return nil, ErrInternal
	}

	return questionAnswerPairs, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
