package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/Plebysnacc/kummerkasten/auth"
	"github.com/Plebysnacc/kummerkasten/graph/model"
	"github.com/Plebysnacc/kummerkasten/middleware"
	"github.com/Plebysnacc/kummerkasten/models"
	"github.com/google/uuid"
	"github.com/uptrace/bun"
)

// CreateTicket is the resolver for the createTicket field.
func (r *mutationResolver) CreateTicket(ctx context.Context, ticket model.NewTicket) (*model.Ticket, error) {
	var labels []*models.Label

	for _, labelName := range ticket.Labels {
		label := &models.Label{}
		err := r.DB.NewSelect().
			Model(label).
			Where("LOWER(name) = ?", strings.ToLower(string(labelName))).
			Limit(1).
			Scan(ctx)
		if err != nil {
			log.Printf("Label not found: %s", labelName)
			return nil, fmt.Errorf("label not found: %s", labelName)
		}
		labels = append(labels, label)
	}

	const MaxTitleLength = 70
	if len(ticket.OriginalTitle) > MaxTitleLength {
		return nil, fmt.Errorf("ticket title exceeds max length of %v", MaxTitleLength)
	}

	const MaxTextLength = 3000
	if len(ticket.Text) > MaxTextLength {
		return nil, fmt.Errorf("ticket text exceeds max length of %v", MaxTextLength)
	}

	dbTicket := &models.Ticket{
		ID:            uuid.New().String(),
		Text:          ticket.Text,
		OriginalTitle: ticket.OriginalTitle,
		Title:         ticket.OriginalTitle,
		State:         model.TicketStateNew,
		Labels:        labels,
		CreatedAt:     time.Now(),
		LastModified:  time.Now(),
	}

	if _, err := r.DB.NewInsert().Model(dbTicket).Exec(ctx); err != nil {
		log.Printf("Failed to create Ticket: %v", err)
		return nil, err
	}

	if len(labels) > 0 {
		var labelsToTickets []models.LabelsToTickets
		for _, label := range labels {
			labelsToTickets = append(labelsToTickets, models.LabelsToTickets{
				LabelID:  label.ID,
				TicketID: dbTicket.ID,
			})
		}
		if _, err := r.DB.NewInsert().Model(&labelsToTickets).Exec(ctx); err != nil {
			log.Printf("Failed to link labels to ticket: %v", err)
		}
	}

	var gqlLabels []*model.Label
	for _, l := range dbTicket.Labels {
		gqlLabels = append(gqlLabels, &model.Label{
			ID:        l.ID,
			Name:      l.Name,
			Color:     l.Color,
			FormLabel: &l.FormLabel,
		})
	}

	gqlTicket := &model.Ticket{
		ID:            dbTicket.ID,
		OriginalTitle: dbTicket.Title,
		Title:         dbTicket.Title,
		Text:          dbTicket.Text,
		State:         dbTicket.State,
		CreatedAt:     dbTicket.CreatedAt,
		LastModified:  dbTicket.LastModified,
		Labels:        gqlLabels,
	}

	return gqlTicket, nil
}

// DeleteTicket is the resolver for the deleteTicket field.
func (r *mutationResolver) DeleteTicket(ctx context.Context, ids []string) (int32, error) {
	result, err := r.DB.NewDelete().Model((*model.Ticket)(nil)).Where("id IN (?)", bun.In(ids)).Exec(ctx)
	if err != nil {
		log.Printf("Failed to delete tickets : %v", err)
		return 0, err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, err
	}

	return int32(rowsAffected), nil
}

// UpdateTicket is the resolver for the updateTicket field.
func (r *mutationResolver) UpdateTicket(ctx context.Context, id string, ticket model.UpdateTicket) (string, error) {
	dbTicket := &models.Ticket{}
	err := r.DB.NewSelect().
		Model(dbTicket).
		Where("id = ?", id).
		Limit(1).
		Scan(ctx)

	if err != nil {
		return "", fmt.Errorf("ticket with id %v not found", id)
	}

	if ticket.Title != nil {
		dbTicket.Title = *ticket.Title
	}
	if ticket.Text != nil {
		dbTicket.Text = *ticket.Text
	}
	if ticket.Note != nil {
		dbTicket.Note = *ticket.Note
	}
	if ticket.State != nil {
		dbTicket.State = *ticket.State
	}

	dbTicket.LastModified = time.Now()

	if _, err := r.DB.NewUpdate().
		Model(dbTicket).
		WherePK().
		Exec(ctx); err != nil {
		log.Printf("Failed to update ticket %s: %v", id, err)
		return "", err
	}

	return dbTicket.ID, nil
}

// UpdateTicketState is the resolver for the updateTicketState field.
func (r *mutationResolver) UpdateTicketState(ctx context.Context, ids []string, state model.TicketState) (int32, error) {
	result, err := r.DB.NewUpdate().Model((*models.Ticket)(nil)).
		Where("id IN (?)", bun.In(ids)).Set("state = ?", state).
		Set("last_modified = ?", time.Now()).Exec(ctx)

	if err != nil {
		log.Printf("Failed to update setting state: %v", err)
		return 0, err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, err
	}

	return int32(rowsAffected), nil
}

// CreateLabel is the resolver for the createLabel field.
func (r *mutationResolver) CreateLabel(ctx context.Context, label model.NewLabel) (*model.Label, error) {
	const MAXLABELLENGTH = 50

	if len(label.Name) > MAXLABELLENGTH {
		return nil, fmt.Errorf("label name exceeds max length of %v", MAXLABELLENGTH)
	}

	var labels []*models.Label

	if err := r.DB.NewSelect().Model(&labels).
		Where("LOWER(name) = ?", strings.ToLower(label.Name)).
		Scan(ctx); err != nil {
		return nil, err
	}

	if len(labels) != 0 {
		return nil, fmt.Errorf("unique constraint error: label with name %v does already exist", label.Name)
	}

	newLabel := &models.Label{
		ID:   uuid.New().String(),
		Name: label.Name,
	}

	if label.Color != nil {
		colorValue := *label.Color
		match, _ := regexp.MatchString("^#[[:xdigit:]]{6}$", colorValue)
		if !match {
			return nil, fmt.Errorf("color was not provided in valid hex format")
		}
		newLabel.Color = colorValue
	}

	if label.FormLabel != nil {
		newLabel.FormLabel = *label.FormLabel
	}

	formBool := newLabel.FormLabel

	if _, err := r.DB.NewInsert().Model(newLabel).Exec(ctx); err != nil {
		log.Printf("Failed to create label: %v", err)
		return nil, err
	}

	return &model.Label{
		ID:        newLabel.ID,
		Name:      newLabel.Name,
		Color:     newLabel.Color,
		FormLabel: &formBool,
		Tickets:   []*model.Ticket{},
	}, nil
}

// DeleteLabel is the resolver for the deleteLabel field.
func (r *mutationResolver) DeleteLabel(ctx context.Context, ids []string) (int32, error) {
	result, err := r.DB.NewDelete().Model((*model.Label)(nil)).Where("id IN (?)", bun.In(ids)).Exec(ctx)
	if err != nil {
		log.Printf("Failed to delete label: %v", err)
		return 0, err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, err
	}

	return int32(rowsAffected), nil
}

// UpdateLabel is the resolver for the updateLabel field.
func (r *mutationResolver) UpdateLabel(ctx context.Context, id string, label model.UpdateLabel) (string, error) {
	dbLabel := &models.Label{}
	err := r.DB.NewSelect().Model(dbLabel).Where("id = ?", id).Scan(ctx)

	if err != nil {
		log.Printf("Failed to find label with id %v: %v", id, err)
		return "", fmt.Errorf("label with id %v not found", id)
	}

	if label.Name != nil {
		const MAXLABELLENGTH = 50
		if len(*label.Name) > MAXLABELLENGTH {
			return "", fmt.Errorf("label name exceeds max length of %v", MAXLABELLENGTH)
		}

		var labels []*models.Label

		if err := r.DB.NewSelect().Model(&labels).
			Where("LOWER(name) = ?", strings.ToLower(*label.Name)).
			Scan(ctx); err != nil {
			return "", err
		}

		if len(labels) != 0 {
			return "", fmt.Errorf("unique constraint error: label with name %v does already exist", label.Name)
		}

		dbLabel.Name = *label.Name
	}

	if label.Color != nil {
		colorValue := *label.Color
		match, _ := regexp.MatchString("^#[[:xdigit:]]{6}$", colorValue)
		if !match {
			return "", fmt.Errorf("color was not provided in valid hex format")
		}

		dbLabel.Color = colorValue
	}

	if label.FormLabel != nil {
		dbLabel.FormLabel = *label.FormLabel
	}

	if _, err := r.DB.NewUpdate().Model(dbLabel).WherePK().Exec(ctx); err != nil {
		log.Printf("Failed to update label %s: %v", id, err)
		return "", err
	}

	return dbLabel.ID, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, user model.NewUser) (*model.User, error) {
	hashedPassword, err := auth.HashPassword(user.Password)

	if err != nil {
		log.Printf("Failed to create user")
	}

	userId := uuid.New().String()

	newUser := &model.User{
		ID:           userId,
		Mail:         user.Mail,
		Firstname:    user.Firstname,
		Lastname:     user.Lastname,
		Password:     hashedPassword,
		Role:         model.UserRoleUser,
		CreatedAt:    time.Now(),
		LastModified: time.Now(),
	}

	if _, err := r.DB.NewInsert().Model(newUser).Exec(ctx); err != nil {
		log.Printf("Failed to create user: %v", err)
		return nil, err
	}

	return newUser, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, ids []string) (int32, error) {
	if len(ids) == 0 {
		return 0, fmt.Errorf("no ids provided to DeleteUser()")
	}

	result, err := r.DB.NewDelete().Model((*model.User)(nil)).Where("ID IN (?)", bun.In(ids)).Exec(ctx)

	if err != nil {
		log.Printf("Failed to delete user: %v", err)
		return 0, err
	}

	rowsAffected, _ := result.RowsAffected()
	return int32(rowsAffected), nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, user model.UpdateUser) (string, error) {
	users, err := r.Query().Users(ctx, []string{id}, make([]string, 0), nil)

	if err != nil || len(users) == 0 {
		return "", fmt.Errorf("user with id %v not found", id)
	}

	updatedUser := users[0]

	if user.Mail != nil {
		updatedUser.Mail = *user.Mail
	}
	if user.Firstname != nil {
		updatedUser.Firstname = *user.Firstname
	}
	if user.Lastname != nil {
		updatedUser.Lastname = *user.Lastname
	}
	if user.Password != nil {
		hashedPassword, err := auth.HashPassword(*user.Password)

		if err != nil {
			log.Printf("Failed to create user: %v", err)
			return "", err
		}

		updatedUser.Password = hashedPassword
	}

	updatedUser.LastModified = time.Now()

	if _, err := r.DB.NewUpdate().Model(updatedUser).
		Where("id = ?", id).
		Exec(ctx); err != nil {
		log.Printf("Failed to update user: %v", err)
		return "", err
	}

	return updatedUser.ID, nil
}

// ChangeRole is the resolver for the changeRole field.
func (r *mutationResolver) ChangeRole(ctx context.Context, id string, role model.UserRole) (string, error) {
	users, err := r.Query().Users(ctx, []string{id}, make([]string, 0), nil)

	if err != nil || len(users) == 0 {
		return "", fmt.Errorf("user with id %v not found", id)
	}

	updatedUser := users[0]

	updatedUser.Role = role
	updatedUser.LastModified = time.Now()

	if _, err := r.DB.NewUpdate().Model(updatedUser).
		Where("id = ?", id).
		Exec(ctx); err != nil {
		log.Printf("Failed to update user role: %v", err)
		return "", err
	}

	return updatedUser.ID, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context, sid string) (string, error) {
	if _, err := r.DB.NewDelete().Model((*model.Session)(nil)).
		Where("id = ?", sid).
		Exec(ctx); err != nil {
		log.Printf("Failed to logout user: %v", err)
		return "", err
	}

	return "", nil
}

// CreateSetting is the resolver for the createSetting field.
func (r *mutationResolver) CreateSetting(ctx context.Context, setting model.NewSetting) (*model.Setting, error) {
	insertedSetting := &model.Setting{
		Value: setting.Value,
		Key:   setting.Key,
	}

	if _, err := r.DB.NewInsert().Model(insertedSetting).Exec(ctx); err != nil {
		log.Printf("Failed to create setting: %v", err)
		return nil, err
	}

	return insertedSetting, nil
}

// DeleteSetting is the resolver for the deleteSetting field.
func (r *mutationResolver) DeleteSetting(ctx context.Context, keys []string) (int32, error) {
	count, err := r.DB.NewSelect().Model((*model.Setting)(nil)).Where("key IN (?)", bun.In(keys)).Count(ctx)
	if err != nil || count == 0 {
		return 0, nil
	}
	_, err = r.DB.NewDelete().Model((*model.Setting)(nil)).Where("key IN (?)", bun.In(keys)).Exec(ctx)
	if err != nil {
		log.Printf("Failed to delete settings : %v", err)
		return 0, err
	}

	return int32(count), nil
}

// UpdateSetting is the resolver for the updateSetting field.
func (r *mutationResolver) UpdateSetting(ctx context.Context, setting model.NewSetting) (*model.Setting, error) {
	updateSetting := &model.Setting{
		Key:   setting.Key,
		Value: setting.Value,
	}

	if _, err := r.DB.NewUpdate().Model(updateSetting).Where("key = ?", setting.Key).Exec(ctx); err != nil {
		log.Printf("Failed to update setting %s: %v", setting.Key, err)
		return nil, err
	}

	return updateSetting, nil
}

// AddLabelToTicket is the resolver for the addLabelToTicket field.
func (r *mutationResolver) AddLabelToTicket(ctx context.Context, assignments []*model.LabelToTicketAssignment) (int32, error) {
	var labelsToTicketsEntries []*models.LabelsToTickets
	updatedTickets := make(map[string]struct{})

	for _, assignment := range assignments {
		if assignment.TicketID == "" || assignment.LabelID == "" {
			return 0, fmt.Errorf("ticketId and labelId cannot be empty")
		}

		labelsToTicketsEntries = append(labelsToTicketsEntries, &models.LabelsToTickets{
			TicketID: assignment.TicketID,
			LabelID:  assignment.LabelID,
		})

		updatedTickets[assignment.TicketID] = struct{}{}
	}

	for ticketID := range updatedTickets {
		_, err := r.UpdateTicket(ctx, ticketID, model.UpdateTicket{})
		if err != nil {
			log.Printf("Failed to update LastModified: %v", err)
		}
	}

	result, err := r.DB.NewInsert().Model(&labelsToTicketsEntries).Exec(ctx)
	if err != nil {
		log.Printf("Failed to add labels to tickets: %v", err)
		return 0, err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, err
	}

	return int32(rowsAffected), nil
}

// RemoveLabelFromTicket is the resolver for the removeLabelFromTicket field.
func (r *mutationResolver) RemoveLabelFromTicket(ctx context.Context, assignments []*model.LabelToTicketAssignment) (int32, error) {
	updatedTickets := make(map[string]struct{})
	var rowsAffected int64

	for _, assignment := range assignments {
		if assignment.TicketID == "" || assignment.LabelID == "" {
			return 0, fmt.Errorf("ticketId and labelId cannot be empty")
		}

		result, err := r.DB.NewDelete().Model(&models.LabelsToTickets{}).
			Where("ticket_id = ?", assignment.TicketID).Where("label_id = ?", assignment.LabelID).Exec(ctx)

		if err != nil {
			log.Printf("Failed to remove label '%s' from ticket '%s': %v", assignment.LabelID, assignment.TicketID, err)
			return int32(rowsAffected), err
		}

		removalRowsAffected, err := result.RowsAffected()
		if err != nil {
			log.Printf("Failed to read affected rows: %v", err)
			return int32(rowsAffected), err
		}

		rowsAffected = removalRowsAffected + rowsAffected

		updatedTickets[assignment.TicketID] = struct{}{}

	}

	for ticketID := range updatedTickets {
		_, err := r.UpdateTicket(ctx, ticketID, model.UpdateTicket{})
		if err != nil {
			log.Printf("Failed to update LastModified: %v", err)
		}
	}

	return int32(rowsAffected), nil
}

// CreateQuestionAnswerPair is the resolver for the createQuestionAnswerPair field.
func (r *mutationResolver) CreateQuestionAnswerPair(ctx context.Context, questionAnswerPair model.NewQuestionAnswerPair) (*model.QuestionAnswerPair, error) {
	createdQuestionAnswerPair := &model.QuestionAnswerPair{
		ID:       uuid.New().String(),
		Question: questionAnswerPair.Question,
		Answer:   questionAnswerPair.Answer,
	}

	if _, err := r.DB.NewInsert().Model(createdQuestionAnswerPair).Exec(ctx); err != nil {
		log.Printf("Failed to create QuestionAnswerPair: %v", err)
		return nil, err
	}

	return createdQuestionAnswerPair, nil
}

// DeleteQuestionAnswerPair is the resolver for the deleteQuestionAnswerPair field.
func (r *mutationResolver) DeleteQuestionAnswerPair(ctx context.Context, ids []string) (int32, error) {
	result, err := r.DB.NewDelete().Model((*model.QuestionAnswerPair)(nil)).Where("id IN (?)", bun.In(ids)).Exec(ctx)
	if err != nil {
		log.Printf("Failed to delete QuestionAnswerPair : %v", err)
		return 0, err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, err
	}

	return int32(rowsAffected), nil
}

// UpdateQuestionAnswerPair is the resolver for the updateQuestionAnswerPair field.
func (r *mutationResolver) UpdateQuestionAnswerPair(ctx context.Context, id string, questionAnswerPair model.UpdateQuestionAnswerPair) (string, error) {
	questionAnswerPairs, err := r.Query().QuestionAnswerPairs(ctx, []string{id})

	if err != nil || len(questionAnswerPairs) == 0 {
		return "", fmt.Errorf("question_answer_pair with id %v not found", id)
	}

	qAP := questionAnswerPairs[0]

	if questionAnswerPair.Question != nil {
		qAP.Question = *questionAnswerPair.Question
	}
	if questionAnswerPair.Answer != nil {
		qAP.Answer = *questionAnswerPair.Answer
	}

	if _, err := r.DB.NewUpdate().Model(qAP).
		Where("id = ?", id).
		Exec(ctx); err != nil {
		log.Printf("Failed to update QuestionAnswerPair: %v", err)
		return "", err
	}

	return qAP.ID, nil
}

// Tickets is the resolver for the tickets field.
func (r *queryResolver) Tickets(ctx context.Context, id []string, state []model.TicketState) ([]*model.Ticket, error) {
	var dbTickets []*models.Ticket

	query := r.DB.NewSelect().Model(&dbTickets).Relation("Labels")

	if len(id) > 0 {
		query = query.Where("ticket.id IN (?)", bun.In(id))
	}

	if len(state) > 0 {
		query = query.Where("ticket.state IN (?)", bun.In(state))
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get tickets: %v", err)
		return nil, err
	}

	var gqlTickets []*model.Ticket
	for _, t := range dbTickets {
		var gqlLabels []*model.Label
		for _, l := range t.Labels {
			form := l.FormLabel
			gqlLabels = append(gqlLabels, &model.Label{
				ID:        l.ID,
				Name:      l.Name,
				FormLabel: &form,
				Color:     l.Color,
			})
		}

		gqlTickets = append(gqlTickets, &model.Ticket{
			ID:            t.ID,
			OriginalTitle: t.OriginalTitle,
			Title:         t.Title,
			Text:          t.Text,
			Note:          &t.Note,
			State:         t.State,
			CreatedAt:     t.CreatedAt,
			LastModified:  t.LastModified,
			Labels:        gqlLabels,
		})
	}

	return gqlTickets, nil
}

// Labels is the resolver for the labels field.
func (r *queryResolver) Labels(ctx context.Context, ids []string) ([]*model.Label, error) {
	var dbLabels []*models.Label

	query := r.DB.NewSelect().Model(&dbLabels).Relation("Tickets")

	if len(ids) > 0 {
		query = query.Where("label.id IN (?)", bun.In(ids))
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get labels: %v", err)
		return nil, err
	}

	var gqlLabels []*model.Label
	for _, l := range dbLabels {
		var gqlTickets []*model.Ticket
		for _, t := range l.Tickets {
			gqlTickets = append(gqlTickets, &model.Ticket{
				ID:           t.ID,
				Title:        t.Title,
				Text:         t.Text,
				Note:         &t.Note,
				State:        t.State,
				CreatedAt:    t.CreatedAt,
				LastModified: t.LastModified,
			})
		}

		gqlLabels = append(gqlLabels, &model.Label{
			ID:        l.ID,
			Name:      l.Name,
			Color:     l.Color,
			FormLabel: &l.FormLabel,
			Tickets:   gqlTickets,
		})
	}

	return gqlLabels, nil
}

// FormLabels is the resolver for the formLabels field.
func (r *queryResolver) FormLabels(ctx context.Context, ids []string) ([]*model.Label, error) {
	var dbLabels []*models.Label

	query := r.DB.NewSelect().Model(&dbLabels).Relation("Tickets")

	if len(ids) > 0 {
		query = query.Where("label.id IN (?)", bun.In(ids))
	}

	query = query.Where("label.form_label = ?", true)

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get form labels: %v", err)
		return nil, err
	}

	var gqlLabels []*model.Label
	for _, l := range dbLabels {
		var gqlTickets []*model.Ticket
		for _, t := range l.Tickets {
			gqlTickets = append(gqlTickets, &model.Ticket{
				ID:           t.ID,
				Title:        t.Title,
				Text:         t.Text,
				Note:         &t.Note,
				State:        t.State,
				CreatedAt:    t.CreatedAt,
				LastModified: t.LastModified,
			})
		}

		gqlLabels = append(gqlLabels, &model.Label{
			ID:        l.ID,
			Name:      l.Name,
			Color:     l.Color,
			FormLabel: &l.FormLabel,
			Tickets:   gqlTickets,
		})
	}

	return gqlLabels, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, id []string, mail []string, role *model.UserRole) ([]*model.User, error) {
	var users []*model.User

	query := r.DB.NewSelect().Model(&users)

	if len(id) > 0 {
		query = query.Where("id IN (?)", bun.In(id))
	}
	if len(mail) > 0 {
		query = query.Where("mail IN (?)", bun.In(mail))
	}
	if role != nil {
		query = query.Where("role = ?", *role)
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to fetch users: %v", err)
		return nil, err
	}

	return users, nil
}

// Settings is the resolver for the settings field.
func (r *queryResolver) Settings(ctx context.Context, keys []string) ([]*model.Setting, error) {
	var settings []*model.Setting

	query := r.DB.NewSelect().Model(&settings)

	if len(keys) > 0 {
		query = query.Where("key IN (?)", bun.In(keys))
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get settings: %v", err)
		return nil, err
	}

	return settings, nil
}

// Login is the resolver for the login field.
func (r *queryResolver) Login(ctx context.Context, mail string, password string) (bool, error) {
	users, err := r.Users(ctx, make([]string, 0), []string{mail}, nil)
	if err != nil || len(users) == 0 {
		log.Printf("Failed to fetch user for login: %v", err)
		return false, err
	}

	user := users[0]
	hashedPassword := user.Password

	if err := auth.VerifyPassword(hashedPassword, password); err != nil {
		log.Printf("Password is incorrect for %v is incorrect", user.Mail)
		return false, nil
	}

	newSid := uuid.New().String()
	now := time.Now()
	user.LastLogin = &now
	expiresAt := now.AddDate(0, 0, 2)

	newSession := &model.Session{
		ID:        newSid,
		UserID:    user.ID,
		ExpiresAt: expiresAt,
	}

	if _, err := r.DB.NewInsert().Model(newSession).Exec(ctx); err != nil {
		log.Printf("Failed to create new session: %v", err)
		return false, err
	}

	if _, err := r.DB.NewUpdate().Model(user).Where("mail = ?", mail).Exec(ctx); err != nil {
		log.Printf("Failed to update sid: %v", err)
		return false, err
	}

	httpResponseWriter := ctx.Value(middleware.WriterKey).(http.ResponseWriter)

	http.SetCookie(httpResponseWriter, &http.Cookie{
		Name:     "sid",
		Value:    newSid,
		Path:     "/",
		HttpOnly: true,
		Secure:   os.Getenv("ENV") != "DEV",
		SameSite: http.SameSiteLaxMode,
		Expires:  expiresAt,
	})

	var userSessions []*model.Session
	if _, err := r.DB.NewSelect().
		Model(&userSessions).
		Where("user_id = ?", user.ID).
		Order("expires_at DESC").
		Exec(ctx); err != nil {
		return false, err
	}

	const MaxSessionsPerUser = 20
	if len(userSessions) > MaxSessionsPerUser {
		sessionsToDelete := userSessions[:MaxSessionsPerUser]

		if _, err := r.DB.NewDelete().Model(&sessionsToDelete).Exec(ctx); err != nil {
			return false, err
		}
	}

	return true, nil
}

// LoginCheck is the resolver for the loginCheck field.
func (r *queryResolver) LoginCheck(ctx context.Context, sid *string) (*model.User, error) {
	if sid == nil {
		return nil, nil
	}

	var sessions []*model.Session

	if err := r.DB.NewSelect().Model(&sessions).Where("id = ?", sid).Scan(ctx); err != nil {
		return nil, err
	}

	if sessions == nil {
		return nil, nil
	}

	var users []*model.User

	if err := r.DB.NewSelect().Model(&users).
		Where("id = ?", sessions[0].UserID).
		Scan(ctx); err != nil {
		return nil, err
	}

	if users == nil || len(users) > 1 {
		return nil, nil
	}

	return users[0], nil
}

// QuestionAnswerPairs is the resolver for the questionAnswerPairs field.
func (r *queryResolver) QuestionAnswerPairs(ctx context.Context, ids []string) ([]*model.QuestionAnswerPair, error) {
	var questionAnswerPairs []*model.QuestionAnswerPair

	query := r.DB.NewSelect().Model(&questionAnswerPairs)

	if len(ids) > 0 {
		query = query.Where("id IN (?)", bun.In(ids))
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get QuestionAnswerPairs: %v", err)
		return nil, err
	}

	return questionAnswerPairs, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
