package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"fmt"
	"log"
	"regexp"
	"strings"
	"time"

	"github.com/Plebysnacc/kummerkasten/auth"
	"github.com/Plebysnacc/kummerkasten/graph/model"
	"github.com/google/uuid"
	"github.com/uptrace/bun"
)

// CreateTicket is the resolver for the createTicket field.
func (r *mutationResolver) CreateTicket(ctx context.Context, ticket model.NewTicket) (*model.Ticket, error) {
	var labels []*model.Label

	for _, formLabel := range ticket.Labels {
		label := &model.Label{}
		err := r.DB.NewSelect().
			Model(label).
			Where("name = ?", formLabel.String()).
			Limit(1).
			Scan(ctx)
		if err != nil {
			log.Printf("Label not found: %s", formLabel.String())
			return nil, fmt.Errorf("label not found: %s", formLabel.String())
		}
		labels = append(labels, label)
	}

	insertedTicket := &model.Ticket{
		ID:           uuid.New().String(),
		Text:         ticket.Text,
		Title:        ticket.Title,
		State:        model.TicketStateNew,
		Labels:       labels,
		CreatedAt:    time.Now(),
		LastModified: time.Now(),
	}

	if _, err := r.DB.NewInsert().Model(insertedTicket).Exec(ctx); err != nil {
		log.Printf("Failed to create Ticket: %v", err)
		return nil, err
	}

	return insertedTicket, nil
}

// DeleteTicket is the resolver for the deleteTicket field.
func (r *mutationResolver) DeleteTicket(ctx context.Context, ids []string) (int32, error) {
	result, err := r.DB.NewDelete().Model((*model.Ticket)(nil)).Where("id IN (?)", bun.In(ids)).Exec(ctx)
	if err != nil {
		log.Printf("Failed to delete tickets : %v", err)
		return 0, err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, err
	}

	return int32(rowsAffected), nil
}

// UpdateTicket is the resolver for the updateTicket field.
func (r *mutationResolver) UpdateTicket(ctx context.Context, id string, ticket model.UpdateTicket) (string, error) {
	tickets, err := r.Query().Tickets(ctx, []string{id}, nil)

	if err != nil || len(tickets) == 0 {
		return "", fmt.Errorf("ticket with id %v not found", id)
	}

	updatedTicket := tickets[0]

	if ticket.Title != nil {
		updatedTicket.Title = *ticket.Title
	}
	if ticket.Text != nil {
		updatedTicket.Text = *ticket.Text
	}
	if ticket.Note != nil {
		updatedTicket.Note = ticket.Note
	}
	if ticket.State != nil {
		updatedTicket.State = *ticket.State
	}

	updatedTicket.LastModified = time.Now()

	if _, err := r.DB.NewUpdate().Model(updatedTicket).Where("id = ?", id).Exec(ctx); err != nil {
		log.Printf("Failed to update ticket %s: %v", id, err)
		return "", err
	}

	return updatedTicket.ID, nil
}

// UpdateTicketState is the resolver for the updateTicketState field.
func (r *mutationResolver) UpdateTicketState(ctx context.Context, ids []string, state model.TicketState) (int32, error) {
	result, err := r.DB.NewUpdate().
		Model((*model.Ticket)(nil)).
		Where("id IN (?)", bun.In(ids)).
		Set("state = ?", state).
		Set("last_modified = ?", time.Now()).
		Exec(ctx)

	if err != nil {
		log.Printf("Failed to update setting state: %v", err)
		return 0, err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, err
	}

	return int32(rowsAffected), nil
}

// CreateLabel is the resolver for the createLabel field.
func (r *mutationResolver) CreateLabel(ctx context.Context, label model.NewLabel) (*model.Label, error) {
	colorValue := label.Color
	match, _ := regexp.MatchString("^#[[:xdigit:]]{6}$", colorValue)
	if !match {
		return nil, fmt.Errorf("color was not provided in valid hex format")
	}

	insertedLabel := &model.Label{
		ID:      uuid.New().String(),
		Name:    strings.ToLower(label.Name),
		Color:   label.Color,
		Tickets: make([]*model.Ticket, 0),
	}

	if _, err := r.DB.NewInsert().Model(insertedLabel).Exec(ctx); err != nil {
		log.Printf("Failed to create label: %v", err)
		return nil, err
	}

	return insertedLabel, nil
}

// DeleteLabel is the resolver for the deleteLabel field.
func (r *mutationResolver) DeleteLabel(ctx context.Context, ids []int32) (int32, error) {
	result, err := r.DB.NewDelete().Model((*model.Label)(nil)).Where("id IN (?)", bun.In(ids)).Exec(ctx)
	if err != nil {
		log.Printf("Failed to delete label: %v", err)
		return 0, err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, err
	}

	return int32(rowsAffected), nil
}

// UpdateLabel is the resolver for the updateLabel field.
func (r *mutationResolver) UpdateLabel(ctx context.Context, id string, label model.UpdateLabel) (string, error) {
	labels, err := r.Query().Labels(ctx, []string{id})

	if err != nil || len(labels) == 0 {
		return "", fmt.Errorf("label with id %v not found", id)
	}

	updatedLabel := labels[0]

	if label.Name != nil {
		updatedLabel.Name = strings.ToLower(*label.Name)
	}

	if label.Color != nil {
		colorValue := *label.Color
		match, _ := regexp.MatchString("^#[[:xdigit:]]{6}$", colorValue)
		if !match {
			return "", fmt.Errorf("color was not provided in valid hex format")
		}

		updatedLabel.Color = colorValue
	}

	if _, err := r.DB.NewUpdate().Model(updatedLabel).Where("id = ?", id).Exec(ctx); err != nil {
		log.Printf("Failed to update label %s: %v", id, err)
		return "", err
	}

	return updatedLabel.ID, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, user model.NewUser) (*model.User, error) {
	sid, _ := auth.GenerateSID()

	hashedPassword, err := auth.HashPassword(user.Password)

	if err != nil {
		log.Printf("Failed to create user")
	}

	newUser := &model.User{
		ID:           uuid.New().String(),
		Sid:          sid,
		Mail:         user.Mail,
		Firstname:    user.Firstname,
		Lastname:     user.Lastname,
		Password:     hashedPassword,
		Role:         model.UserRoleUser,
		CreatedAt:    time.Now(),
		LastModified: time.Now(),
	}

	if _, err := r.DB.NewInsert().Model(newUser).Exec(ctx); err != nil {
		log.Printf("Failed to create user: %v", err)
		return nil, err
	}

	return newUser, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, ids []string) (int32, error) {
	if len(ids) == 0 {
		return 0, fmt.Errorf("no ids provided to DeleteUser()")
	}

	result, err := r.DB.NewDelete().Model((*model.User)(nil)).Where("ID IN (?)", bun.In(ids)).Exec(ctx)

	if err != nil {
		log.Printf("Failed to delete user: %v", err)
		return 0, err
	}

	rowsAffected, _ := result.RowsAffected()
	return int32(rowsAffected), nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, user model.UpdateUser) (string, error) {
	users, err := r.Query().Users(ctx, []string{id}, make([]string, 0), nil)

	if err != nil || len(users) == 0 {
		return "", fmt.Errorf("user with id %v not found", id)
	}

	updatedUser := users[0]

	if user.Mail != nil {
		updatedUser.Mail = *user.Mail
	}
	if user.Firstname != nil {
		updatedUser.Firstname = *user.Firstname
	}
	if user.Lastname != nil {
		updatedUser.Lastname = *user.Lastname
	}
	if user.Password != nil {
		hashedPassword, err := auth.HashPassword(*user.Password)

		if err != nil {
			log.Printf("Failed to create user: %v", err)
			return "", err
		}

		updatedUser.Password = hashedPassword
	}
	if user.Role != nil {
		updatedUser.Role = *user.Role
	}
	if user.Sid != nil {
		updatedUser.Sid = *user.Sid
	}

	updatedUser.LastModified = time.Now()

	if _, err := r.DB.NewUpdate().Model(updatedUser).
		Where("id = ?", id).
		Exec(ctx); err != nil {
		log.Printf("Failed to update user: %v", err)
		return "", err
	}

	return updatedUser.Sid, nil
}

// CreateSetting is the resolver for the createSetting field.
func (r *mutationResolver) CreateSetting(ctx context.Context, setting model.NewSetting) (*model.Setting, error) {
	insertedSetting := &model.Setting{
		Value: setting.Value,
		Key:   setting.Key,
	}

	if _, err := r.DB.NewInsert().Model(insertedSetting).Exec(ctx); err != nil {
		log.Printf("Failed to create setting: %v", err)
		return nil, err
	}

	return insertedSetting, nil
}

// DeleteSetting is the resolver for the deleteSetting field.
func (r *mutationResolver) DeleteSetting(ctx context.Context, keys []string) (int32, error) {
	result, err := r.DB.NewDelete().Model((*model.Setting)(nil)).Where("key IN (?)", bun.In(keys)).Exec(ctx)
	if err != nil {
		log.Printf("Failed to delete settings : %v", err)
		return 0, err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Failed to read affected rows: %v", err)
		return 0, err
	}

	return int32(rowsAffected), nil
}

// UpdateSetting is the resolver for the updateSetting field.
func (r *mutationResolver) UpdateSetting(ctx context.Context, setting model.NewSetting) (*model.Setting, error) {
	updateSetting := &model.Setting{
		Key:   setting.Key,
		Value: setting.Value,
	}

	if _, err := r.DB.NewUpdate().Model(updateSetting).Where("key = ?", setting.Key).Exec(ctx); err != nil {
		log.Printf("Failed to update setting %s: %v", setting.Key, err)
		return nil, err
	}

	return updateSetting, nil
}

// AddLabelToTicket is the resolver for the addLabelToTicket field.
func (r *mutationResolver) AddLabelToTicket(ctx context.Context, assignment []*model.NewLabelToTicketAssignment) (int32, error) {
	panic(fmt.Errorf("not implemented: AddLabelToTicket - addLabelToTicket"))
}

// RemoveLabelFromTicket is the resolver for the removeLabelFromTicket field.
func (r *mutationResolver) RemoveLabelFromTicket(ctx context.Context, labelID string, ticketID int32) (int32, error) {
	panic(fmt.Errorf("not implemented: RemoveLabelFromTicket - removeLabelFromTicket"))
}

// Tickets is the resolver for the tickets field.
func (r *queryResolver) Tickets(ctx context.Context, id []string, state []model.TicketState) ([]*model.Ticket, error) {
	var tickets []*model.Ticket

	query := r.DB.NewSelect().Model(&tickets)

	if len(id) > 0 {
		query = query.Where("id IN (?)", bun.In(id))
	}

	if len(state) > 0 {
		query = query.Where("state IN (?)", bun.In(state))
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get tickets: %v", err)
		return nil, err
	}

	return tickets, nil
}

// Labels is the resolver for the labels field.
func (r *queryResolver) Labels(ctx context.Context, ids []string) ([]*model.Label, error) {
	var labels []*model.Label

	query := r.DB.NewSelect().Model(&labels)

	if len(ids) > 0 {
		query = query.Where("id IN (?)", bun.In(ids))
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get labels: %v", err)
		return nil, err
	}

	return labels, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, id []string, mail []string, role *model.UserRole) ([]*model.User, error) {
	var users []*model.User

	query := r.DB.NewSelect().Model(&users)

	if len(id) > 0 {
		query = query.Where("id IN (?)", bun.In(id))
	}
	if len(mail) > 0 {
		query = query.Where("mail IN (?)", bun.In(mail))
	}
	if role != nil {
		query = query.Where("role = ?", *role)
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to fetch users: %v", err)
		return nil, err
	}

	return users, nil
}

// Settings is the resolver for the settings field.
func (r *queryResolver) Settings(ctx context.Context, keys []string) ([]*model.Setting, error) {
	var settings []*model.Setting

	query := r.DB.NewSelect().Model(&settings)

	if len(keys) > 0 {
		query = query.Where("key IN (?)", bun.In(keys))
	}

	if err := query.Scan(ctx); err != nil {
		log.Printf("Failed to get settings: %v", err)
		return nil, err
	}

	return settings, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
